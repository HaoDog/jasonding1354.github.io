<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason&#39;s Techblog</title>
  <subtitle>Technician =&gt; Scientist =&gt; Philosopher =&gt; Artists</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.jasonding.top/"/>
  <updated>2016-03-16T06:24:42.000Z</updated>
  <id>http://blog.jasonding.top/</id>
  
  <author>
    <name>Jason Ding</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习系列</title>
    <link href="http://blog.jasonding.top/2018/01/01/MLStick/"/>
    <id>http://blog.jasonding.top/2018/01/01/MLStick/</id>
    <published>2018-01-01T03:05:20.000Z</published>
    <updated>2016-03-16T06:24:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Data science is best learned by doing, but a good foundation of statistics and machine learning matters too.</p>
</blockquote>
<p>有关Python的科学计算和机器学习库的使用和学习实例，请参考我的github项目<a href="https://github.com/jasonding1354/pyDataScienceToolkits_Base" target="_blank" rel="external">pyDataScienceToolkits_Base</a>，喜欢就给我star哦！</p>
<h1 id="机器学习基础系列文章"><a href="#机器学习基础系列文章" class="headerlink" title="机器学习基础系列文章"></a>机器学习基础系列文章</h1><ul>
<li><a href="http://jasonding1354.github.io/2014/11/30/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E5%BC%95%E5%85%A5/" target="_blank" rel="external">机器学习基础引入</a></li>
<li><a href="http://jasonding1354.github.io/2014/12/03/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%92%8C%E9%80%82%E7%94%A8%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="external">机器学习算法的分类</a>——关于如何选择机器学习算法和适用解决的问题</li>
<li><a href="http://jasonding1354.github.io/2014/12/02/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B/" target="_blank" rel="external">生成模型和判别模型</a></li>
<li><a href="http://jasonding1354.github.io/2014/12/08/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E4%BB%8E%E6%84%9F%E7%9F%A5%E5%99%A8%E6%A8%A1%E5%9E%8B%E8%AF%B4%E8%B5%B7/" target="_blank" rel="external">从感知机模型说起</a></li>
<li><a href="http://jasonding1354.github.io/2014/12/10/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E7%90%86%E8%A7%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%BA%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94PAC%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/" target="_blank" rel="external">理解为什么机器可以学习——PAC学习模型</a></li>
<li><a href="http://jasonding1354.github.io/2014/12/10/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E7%90%86%E8%A7%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%BA%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Hoeffding%E4%B8%8D%E7%AD%89%E5%BC%8F/" target="_blank" rel="external">理解为什么机器可以学习——Hoeffding不等式</a></li>
<li><a href="http://jasonding1354.github.io/2014/12/11/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E7%90%86%E8%A7%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%BA%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94VC%E7%90%86%E8%AE%BA/" target="_blank" rel="external">理解为什么机器可以学习——VC理论</a></li>
<li><a href="http://jasonding1354.github.io/2014/12/17/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91VC%E7%BB%B4%E4%B8%8E%E6%A8%A1%E5%9E%8B%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E6%A0%B7%E6%9C%AC%E5%A4%8D%E6%9D%82%E5%BA%A6/" target="_blank" rel="external">VC维与模型复杂度、样本复杂度</a></li>
<li><a href="http://jasonding1354.github.io/2014/12/31/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E5%99%AA%E5%A3%B0%E4%B8%8E%E8%AF%AF%E5%B7%AE/" target="_blank" rel="external">噪声与误差</a></li>
<li><a href="http://jasonding1354.github.io/2015/01/07/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%9F%BA%E7%A1%80/" target="_blank" rel="external">线性回归基础</a></li>
<li><a href="http://jasonding1354.github.io/2015/01/09/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91Logistic%E5%9B%9E%E5%BD%92%E5%9F%BA%E7%A1%80/" target="_blank" rel="external">Logistic回归基础</a></li>
<li><a href="http://jasonding1354.github.io/2015/01/12/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E5%B0%86%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E7%94%A8%E4%BA%8E%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/" target="_blank" rel="external">将回归模型用于分类问题</a></li>
<li><a href="http://jasonding1354.github.io/2015/02/01/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/" target="_blank" rel="external">非线性变换</a></li>
<li><a href="http://jasonding1354.github.io/2015/02/09/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E8%BF%87%E6%8B%9F%E5%90%88/" target="_blank" rel="external">过拟合</a></li>
<li><a href="http://jasonding1354.github.io/2015/02/10/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E6%AD%A3%E5%88%99%E5%8C%96/" target="_blank" rel="external">正则化</a></li>
<li><a href="http://jasonding1354.github.io/2015/03/02/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E9%AA%8C%E8%AF%81/" target="_blank" rel="external">验证</a></li>
<li><a href="http://jasonding1354.github.io/2015/03/04/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E6%8A%80%E5%B7%A7%E5%8E%9F%E5%88%99/" target="_blank" rel="external">机器学习中的三个技巧原则</a></li>
<li><a href="http://jasonding1354.github.io/2015/03/05/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E7%BA%BF%E6%80%A7%E5%8F%AF%E5%88%86%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="external">线性可分支持向量机</a></li>
<li><a href="http://jasonding1354.github.io/2015/04/16/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E5%AF%B9%E5%81%B6%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="external">对偶支持向量机</a></li>
<li><a href="http://jasonding1354.github.io/2015/04/16/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E6%A0%B8%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="external">核支持向量机</a></li>
<li><a href="http://jasonding1354.github.io/2015/04/17/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E8%BD%AF%E9%97%B4%E9%9A%94%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="external">软间隔支持向量机</a></li>
<li><a href="http://jasonding1354.github.io/2015/04/22/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E6%A0%B8%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/" target="_blank" rel="external">核逻辑回归</a></li>
<li><a href="http://jasonding1354.github.io/2015/05/01/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92/" target="_blank" rel="external">支持向量回归</a></li>
<li><a href="http://jasonding1354.github.io/2015/06/10/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E6%B7%B7%E5%90%88%E5%92%8C%E8%A3%85%E8%A2%8B/" target="_blank" rel="external">混合和装袋</a></li>
<li><a href="http://jasonding1354.github.io/2015/06/11/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E8%87%AA%E9%80%82%E5%BA%94%E6%8F%90%E5%8D%87/" target="_blank" rel="external">自适应提升</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/22/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/" target="_blank" rel="external">决策树算法</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/23/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E7%AE%97%E6%B3%95/" target="_blank" rel="external">随机森林算法</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/24/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E6%A2%AF%E5%BA%A6%E6%8F%90%E5%8D%87%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="external">梯度提升决策树</a><br><a href=""></a></li>
</ul>
<hr>
<h1 id="机器学习的数学背景系列文章"><a href="#机器学习的数学背景系列文章" class="headerlink" title="机器学习的数学背景系列文章"></a>机器学习的数学背景系列文章</h1><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="* 数学基础"></a>* 数学基础</h2><ul>
<li><a href="http://jasonding1354.github.io/2015/01/19/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E3%80%91%E4%BB%8E%E8%A5%BF%E6%A0%BC%E7%8E%9B%E4%BB%A3%E6%95%B0%E3%80%81%E6%B5%8B%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%88%B0%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/" target="_blank" rel="external">从西格玛代数、测度空间到随机变量</a></li>
<li><a href="http://jasonding1354.github.io/2015/01/22/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E3%80%91%E5%B9%BF%E4%B9%89%E9%80%86%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E5%8F%8A%E5%85%B6%E7%89%B9%E4%BE%8B/" target="_blank" rel="external">广义逆高斯分布及其特例</a></li>
<li><a href="http://jasonding1354.github.io/2015/02/10/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E3%80%91%E6%AF%94%E4%BE%8B%E6%B7%B7%E5%90%88%E5%88%86%E5%B8%83/" target="_blank" rel="external">比例混合分布</a></li>
</ul>
<h2 id="贝叶斯及概率统计角度"><a href="#贝叶斯及概率统计角度" class="headerlink" title="* 贝叶斯及概率统计角度"></a>* 贝叶斯及概率统计角度</h2><ul>
<li><a href="http://jasonding1354.github.io/2015/01/01/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E3%80%91%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0/" target="_blank" rel="external">贝叶斯概念学习</a></li>
<li><a href="http://jasonding1354.github.io/2015/01/02/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E3%80%91%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A1%86%E6%9E%B6%E4%B8%8B%E4%BA%8C%E5%85%83%E7%A6%BB%E6%95%A3%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/" target="_blank" rel="external">贝叶斯框架下二元离散随机变量的概率分布</a></li>
<li><a href=""></a>…</li>
</ul>
<hr>
<h1 id="机器学习实验系列文章"><a href="#机器学习实验系列文章" class="headerlink" title="机器学习实验系列文章"></a>机器学习实验系列文章</h1><ul>
<li><a href="http://jasonding1354.github.io/2014/12/15/Machine%20Learning%20Experiments/%E3%80%90scikit-learn%E3%80%91%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/" target="_blank" rel="external">用Python进行机器学习实验</a></li>
<li><a href="http://jasonding1354.github.io/2014/12/25/Machine%20Learning%20Experiments/%E3%80%90scikit-learn%E3%80%91%E5%AD%A6%E4%B9%A0Python%E6%9D%A5%E5%88%86%E7%B1%BB%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E6%95%B0%E6%8D%AE/" target="_blank" rel="external">学习Python来分类现实世界的数据</a></li>
<li><a href="http://jasonding1354.github.io/2015/03/12/Machine%20Learning%20Experiments/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C%E3%80%91%E6%A6%82%E7%8E%87%E7%BC%96%E7%A8%8B%E5%8F%8A%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%96%B9%E6%B3%95/" target="_blank" rel="external">概率编程及贝叶斯方法</a></li>
<li><a href="http://jasonding1354.github.io/2015/04/17/Machine%20Learning%20Experiments/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C%E3%80%91scikit-learn%E7%9A%84%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9D%97%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">scikit-learn的主要模块和基本使用</a></li>
<li><a href="http://jasonding1354.github.io/2015/04/16/Machine%20Learning%20Experiments/%E3%80%90Kaggle%E3%80%91%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3Biologial%20Response%E9%97%AE%E9%A2%98/" target="_blank" rel="external">用随机森林分类算法解决Biologial Response问题</a></li>
<li><a href="http://jasonding1354.github.io/2015/04/23/Machine%20Learning%20Experiments/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C%E3%80%91%E4%BD%BF%E7%94%A8%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E7%9A%84%E5%88%86%E7%B1%BB/" target="_blank" rel="external">使用朴素贝叶斯进行文本的分类</a></li>
</ul>
<hr>
<h1 id="相似性检索算法系列文章"><a href="#相似性检索算法系列文章" class="headerlink" title="相似性检索算法系列文章"></a>相似性检索算法系列文章</h1><ul>
<li><a href="http://jasonding1354.github.io/2014/09/07/Similarity%20Search/%E3%80%90LSH%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91LSH%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/" target="_blank" rel="external">LSH算法框架分析</a></li>
<li><a href="http://jasonding1354.github.io/2014/09/07/Similarity%20Search/%E3%80%90LSH%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91p%E7%A8%B3%E5%AE%9A%E5%88%86%E5%B8%83LSH%E7%AE%97%E6%B3%95/" target="_blank" rel="external">p稳定分布LSH算法</a></li>
<li><a href="http://jasonding1354.github.io/2015/03/04/Similarity%20Search/%E3%80%90Similarity-Search%E3%80%91Multi-Probe%20LSH%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E9%AB%98%E7%BB%B4%E7%9B%B8%E4%BC%BC%E6%80%A7%E6%90%9C%E7%B4%A2%E7%9A%84%E9%AB%98%E6%95%88%E7%B4%A2%E5%BC%95/" target="_blank" rel="external">Multi-Probe LSH——构建高维相似性搜索的高效索引</a></li>
<li><a href="http://jasonding1354.github.io/2015/03/05/Similarity%20Search/%E3%80%90Similarity-Search%E3%80%91Multi-Probe-LSH%E7%AE%97%E6%B3%95%E6%B7%B1%E5%85%A5/" target="_blank" rel="external">Multi-Probe LSH算法深入</a></li>
</ul>
<hr>
<h1 id="计算机视觉系列文章"><a href="#计算机视觉系列文章" class="headerlink" title="计算机视觉系列文章"></a>计算机视觉系列文章</h1><ul>
<li><a href="http://jasonding1354.github.io/2014/10/16/Machine%20Learning/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E3%80%91OpenCV%E4%B8%AD%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%AE%80%E8%BF%B0/" target="_blank" rel="external">OpenCV中直方图处理函数简述</a></li>
<li><a href="http://jasonding1354.github.io/2014/10/14/Machine%20Learning/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E3%80%91%E5%80%9F%E5%8A%A9%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9D%A5%E6%A3%80%E6%B5%8B%E7%89%B9%E5%AE%9A%E7%89%A9%E2%80%94%E2%80%94MeanShift%E3%80%81CamShift%E7%AE%97%E6%B3%95/" target="_blank" rel="external">借助图像直方图来检测特定物——MeanShift、CamShift算法</a></li>
<li><a href="http://jasonding1354.github.io/2014/10/23/Machine%20Learning/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E3%80%91%E5%9F%BA%E4%BA%8EKalman%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E8%BF%9B%E8%A1%8C%E7%89%A9%E4%BD%93%E7%9A%84%E8%B7%9F%E8%B8%AA/" target="_blank" rel="external">基于Kalman滤波器的进行物体的跟踪</a></li>
<li><a href="http://jasonding1354.github.io/2014/11/04/Machine%20Learning/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E3%80%91LBP%E7%BA%B9%E7%90%86%E7%89%B9%E5%BE%81/" target="_blank" rel="external">LBP纹理特征</a></li>
<li><a href="http://jasonding1354.github.io/2014/12/02/Machine%20Learning/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E3%80%91%E5%AF%B9%E6%A3%80%E6%B5%8B%E7%9A%84%E4%BA%BA%E8%84%B8%E8%BF%9B%E8%A1%8C%E5%89%AA%E5%88%87%E5%92%8C%E5%BD%92%E4%B8%80%E5%8C%96/" target="_blank" rel="external">对检测的人脸进行剪切和归一化</a></li>
<li><a href="http://jasonding1354.github.io/2014/12/28/Machine%20Learning/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E3%80%91OpenCV%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%ABfacerec%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901%E2%80%94%E2%80%94FaceRecognizer%E6%A6%82%E8%BF%B0/" target="_blank" rel="external">OpenCV人脸识别facerec源码分析1——FaceRecognizer概述</a></li>
<li><a href="http://jasonding1354.github.io/2015/03/04/Machine%20Learning/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E3%80%91OpenCV%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%ABfacerec%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902%E2%80%94%E2%80%94LBPH%E6%A6%82%E8%BF%B0/" target="_blank" rel="external">OpenCV人脸识别facerec源码分析2——LBPH概述</a></li>
<li><a href="http://jasonding1354.github.io/2015/03/02/Machine%20Learning/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E3%80%91OpenCV%E7%9A%84%E6%9C%80%E8%BF%91%E9%82%BB%E5%BC%80%E6%BA%90%E5%BA%93FLANN/" target="_blank" rel="external">OpenCV的最近邻开源库FLANN</a></li>
<li><a href="http://jasonding1354.github.io/2015/04/05/Machine%20Learning/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E3%80%91%E6%8F%90%E5%8F%96%E8%A7%86%E9%A2%91%E4%B8%AD%E7%9A%84%E5%89%8D%E6%99%AF%E7%89%A9%E4%BD%93/" target="_blank" rel="external">提取视频中的前景物体</a></li>
</ul>
<p><strong>冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Data science is best learned by doing, but a good foundation of statistics and machine learning matters too.&lt;/p&gt;
&lt;/blockquot
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.jasonding.top/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://blog.jasonding.top/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Spark与Scala学习</title>
    <link href="http://blog.jasonding.top/2018/01/01/ScalaList/"/>
    <id>http://blog.jasonding.top/2018/01/01/ScalaList/</id>
    <published>2018-01-01T02:28:46.000Z</published>
    <updated>2016-03-18T03:18:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spark学习"><a href="#Spark学习" class="headerlink" title="Spark学习"></a>Spark学习</h2><ul>
<li><a href="http://jasonding1354.github.io/2015/05/28/Spark/%E3%80%90Spark%E3%80%91%E9%85%8D%E7%BD%AESpark%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83/" target="_blank" rel="external">配置Spark源码阅读环境</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/07/Spark/%E3%80%90Spark%E3%80%91Spark%E7%9A%84Standalone%E6%A8%A1%E5%BC%8F%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/" target="_blank" rel="external">Spark的Standalone模式安装部署</a></li>
<li><a href="http://jasonding1354.github.io/2015/06/07/Spark/%E3%80%90Spark%E3%80%91Spark%E7%94%9F%E6%80%81%E5%92%8CSpark%E6%9E%B6%E6%9E%84/" target="_blank" rel="external">Spark生态和Spark架构</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/07/Spark/%E3%80%90Spark%E3%80%91Spark%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="external">Spark基本概念</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/08/Spark/%E3%80%90Spark%E3%80%91%E5%BC%B9%E6%80%A7%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%9B%86RDD/" target="_blank" rel="external">弹性分布式数据集RDD概述</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/08/Spark/%E3%80%90Spark%E3%80%91Spark%E5%BA%94%E7%94%A8%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Spark应用执行机制</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/08/Spark/%E3%80%90Spark%E3%80%91RDD%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A31%E2%80%94%E2%80%94Transformation%E5%92%8CActions%E6%A6%82%E5%86%B5/" target="_blank" rel="external">RDD操作详解1——Transformation和Actions概况</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/10/Spark/%E3%80%90Spark%E3%80%91RDD%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A32%E2%80%94%E2%80%94%E5%80%BC%E5%9E%8BTransformation%E7%AE%97%E5%AD%90/" target="_blank" rel="external">RDD操作详解2——值型Transformation算子</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/10/Spark/%E3%80%90Spark%E3%80%91RDD%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A33%E2%80%94%E2%80%94%E9%94%AE%E5%80%BC%E5%9E%8BTransformation%E7%AE%97%E5%AD%90/" target="_blank" rel="external">RDD操作详解3——键值型Transformation算子</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/12/Spark/%E3%80%90Spark%E3%80%91RDD%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A34%E2%80%94%E2%80%94Action%E7%AE%97%E5%AD%90/" target="_blank" rel="external">RDD操作详解4——Action算子</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/14/Spark/%E3%80%90Spark%E3%80%91RDD%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9E%8B/" target="_blank" rel="external">RDD机制实现模型</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/14/Spark/%E3%80%90Spark%E3%80%91Spark%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Spark容错机制</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/14/Spark/%E3%80%90Spark%E3%80%91Spark%E7%9A%84Shuffle%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Spark的Shuffle机制</a><br><a href=""></a></li>
</ul>
<h2 id="Spark深入与源码走读"><a href="#Spark深入与源码走读" class="headerlink" title="Spark深入与源码走读"></a>Spark深入与源码走读</h2><ul>
<li><a href="http://jasonding1354.github.io/2015/07/12/Spark/%E3%80%90Spark%20Core%E3%80%91SparkContext%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" target="_blank" rel="external">SparkContext源码解读</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/14/Spark/%E3%80%90Spark%20Core%E3%80%91DAGScheduler%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/" target="_blank" rel="external">DAGScheduler源码浅析</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/15/Spark/%E3%80%90Spark%20Core%E3%80%91DAGScheduler%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%902/" target="_blank" rel="external">DAGScheduler源码浅析2</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/15/Spark/%E3%80%90Spark%20Core%E3%80%91Stage%E7%94%9F%E6%88%90%E5%92%8CStage%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/" target="_blank" rel="external">Stage生成和Stage源码浅析</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/15/Spark/%E3%80%90Spark%20Core%E3%80%91TaskScheduler%E6%BA%90%E7%A0%81%E4%B8%8E%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%901/" target="_blank" rel="external">TaskScheduler源码与任务提交原理浅析1</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/16/Spark/%E3%80%90Spark%20Core%E3%80%91TaskScheduler%E6%BA%90%E7%A0%81%E4%B8%8E%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%902/" target="_blank" rel="external">TaskScheduler源码与任务提交原理浅析2</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/19/Spark/%E3%80%90Spark%20Core%E3%80%91%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8CTask%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%901/" target="_blank" rel="external">任务执行机制和Task源码浅析1</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/20/Spark/%E3%80%90Spark%20Core%E3%80%91%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8CTask%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%902/" target="_blank" rel="external">任务执行机制和Task源码浅析2</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/20/Spark/%E3%80%90Spark%20Core%E3%80%91%E4%BB%8E%E4%BD%9C%E4%B8%9A%E6%8F%90%E4%BA%A4%E5%88%B0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%AE%8C%E6%95%B4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%85%E6%9E%90/" target="_blank" rel="external">从作业提交到任务调度完整生命周期浅析</a></li>
</ul>
<h2 id="Scala基础"><a href="#Scala基础" class="headerlink" title="Scala基础"></a>Scala基础</h2><ul>
<li><a href="http://jasonding1354.github.io/2015/05/26/Scala/%E3%80%90Scala%E3%80%91Scala%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2/" target="_blank" rel="external">Scala函数式编程初探</a></li>
<li><a href="http://jasonding1354.github.io/2015/05/26/Scala/%E3%80%90Scala%E3%80%91%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/" target="_blank" rel="external">单例对象与伴生对象</a></li>
<li><a href="http://jasonding1354.github.io/2015/06/03/Scala/%E3%80%90Scala%E3%80%91%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8D%B3%E5%AF%B9%E8%B1%A1/" target="_blank" rel="external">头等函数与函数即对象</a></li>
<li><a href="http://jasonding1354.github.io/2015/06/04/Scala/%E3%80%90Scala%E3%80%91%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%92%8C%E6%9F%AF%E9%87%8C%E5%8C%96/" target="_blank" rel="external">高阶函数和柯里化</a></li>
<li><a href="http://jasonding1354.github.io/2015/06/09/Scala/%E3%80%90Scala%E3%80%91Scala%E7%9A%84%E7%B1%BB%E5%B1%82%E7%BA%A7/" target="_blank" rel="external">Scala的类层级</a></li>
<li><a href="http://jasonding1354.github.io/2015/06/11/Scala/%E3%80%90Scala%E3%80%91%E7%89%B9%E8%B4%A8%E4%B8%8E%E7%89%B9%E8%B4%A8%E7%9A%84%E7%BA%BF%E6%80%A7%E5%8C%96/" target="_blank" rel="external">特质与特质的线性化</a></li>
<li><a href="http://jasonding1354.github.io/2015/06/20/Scala/%E3%80%90Scala%E3%80%91%E6%A0%B7%E6%9C%AC%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" target="_blank" rel="external">模式匹配和样本类</a></li>
<li><a href="http://jasonding1354.github.io/2015/06/22/Scala/%E3%80%90Scala%E7%BC%96%E7%A8%8B%E3%80%91%E5%87%BD%E6%95%B0%E5%BC%8F%E9%A3%8E%E6%A0%BC%E7%BC%96%E5%86%99%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" target="_blank" rel="external">函数式风格编写排序算法</a></li>
<li><a href="http://jasonding1354.github.io/2015/06/28/Scala/%E3%80%90Scala%E7%BC%96%E7%A8%8B%E3%80%91%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A8%8B%E5%BA%8F/" target="_blank" rel="external">格式化算术表达式程序</a></li>
<li><a href="http://jasonding1354.github.io/2016/01/14/Scala/%E3%80%90Scala%E3%80%91%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/" target="_blank" rel="external">尾递归优化</a></li>
<li><a href="http://blog.jasonding.top/2016/03/09/Scala/%E3%80%90Scala%E3%80%91%E6%8A%BD%E5%8F%96%E5%99%A8/">抽取器</a></li>
<li><a href="http://blog.jasonding.top/2016/03/11/Scala/%E3%80%90Scala%E3%80%91Cake%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/">Cake模式和依赖注入</a><br><a href=""></a></li>
</ul>
<h2 id="Scala类型系统"><a href="#Scala类型系统" class="headerlink" title="Scala类型系统"></a>Scala类型系统</h2><ul>
<li><a href="http://blog.jasonding.top/2016/02/20/Scala/%E3%80%90Scala%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E3%80%91%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%8C%96%E5%92%8C%E5%8F%98%E5%8C%96%E5%9E%8B%E6%B3%A8%E8%A7%A3/">类型参数化和变化型注解</a></li>
<li><a href="http://blog.jasonding.top/2016/02/20/Scala/%E3%80%90Scala%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E3%80%91%E5%87%BD%E6%95%B0%E5%BC%8FQueue%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/">函数式Queue的简易实现</a></li>
<li><a href="http://blog.jasonding.top/2016/02/21/Scala/%E3%80%90Scala%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E3%80%91%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0/">隐式转换与隐式参数</a></li>
<li><a href="http://blog.jasonding.top/2016/03/15/Scala/%E3%80%90Scala%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E3%80%91%E8%87%AA%E8%BA%AB%E7%B1%BB%E5%9E%8Bself-type/">自身类型self type</a><br><a href=""></a></li>
</ul>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul>
<li><a href="http://blog.jasonding.top/2016/02/22/Functional%20Programming/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91Monads%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94Monoids/">Monads模式初探——Monoids</a></li>
<li><a href="http://blog.jasonding.top/2016/02/23/Functional%20Programming/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91Monads%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94Functor/">Monads模式初探——Functor</a></li>
<li><a href="http://blog.jasonding.top/2016/02/23/Functional%20Programming/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91Monads%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94Endofunctor/">Monads模式初探——Endofunctor</a></li>
<li><a href="http://blog.jasonding.top/2016/03/01/Functional%20Programming/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91Monads%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94Monad%E6%A6%82%E5%BF%B5/">Monads模式初探——Monad概念</a></li>
<li><a href="http://blog.jasonding.top/2016/03/05/Functional%20Programming/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91Monads%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94for%E8%A7%A3%E6%9E%90%E5%BC%8F/">Monads模式初探——for解析式</a></li>
<li><a href="http://blog.jasonding.top/2016/03/05/Functional%20Programming/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91Monads%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94Option-Monad/">Monads模式初探——Option Monad</a><br><a href=""></a></li>
</ul>
<h2 id="Akka编程"><a href="#Akka编程" class="headerlink" title="Akka编程"></a>Akka编程</h2><ul>
<li><a href="http://jasonding1354.github.io/2015/06/26/Scala/%E3%80%90Akka%E3%80%91Actor%E6%A8%A1%E5%9E%8B%E6%8E%A2%E7%B4%A2/" target="_blank" rel="external">Actor模型探索</a></li>
<li><a href="http://jasonding1354.github.io/2016/01/15/Scala/%E3%80%90Akka%E3%80%91Akka%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B%E5%AE%9E%E4%BE%8B/" target="_blank" rel="external">Akka入门编程实例</a></li>
<li><a href="http://jasonding1354.github.io/2016/01/16/Scala/%E3%80%90Akka%E3%80%91Actor%E5%BC%95%E7%94%A8/" target="_blank" rel="external">Actor引用</a></li>
<li><a href="http://jasonding1354.github.io/2016/01/17/Scala/%E3%80%90Akka%E3%80%91Akka%E4%B8%ADactor%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8EDeathWatch%E7%9B%91%E6%8E%A7/" target="_blank" rel="external">Akka中actor的生命周期与DeathWatch监控</a></li>
<li><a href="http://jasonding1354.github.io/2016/01/21/Scala/%E3%80%90Akka%E3%80%91%E5%9C%A8%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8Future/" target="_blank" rel="external">在并发程序中使用Future</a><br><a href=""></a></li>
</ul>
<h2 id="Scala标准库"><a href="#Scala标准库" class="headerlink" title="Scala标准库"></a>Scala标准库</h2><ul>
<li><a href="http://jasonding1354.github.io/2015/06/30/Scala/%E3%80%90Scala%E3%80%91Scala%E7%9A%84Predef%E5%AF%B9%E8%B1%A1/" target="_blank" rel="external">Scala的Predef对象</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/01/Scala/%E3%80%90Scala%E3%80%91Scala%E4%B8%AD%E7%9A%84Nothing%EF%BC%8CNull%EF%BC%8CNone%EF%BC%8CNil/" target="_blank" rel="external">Scala中的Nothing，Null，None，Nil</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/06/Scala/%E3%80%90Scala%E3%80%91%E4%BD%BF%E7%94%A8OptionSomeNone%EF%BC%8C%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8null/" target="_blank" rel="external">使用Option、Some、None，避免使用null</a></li>
<li><a href="http://jasonding1354.github.io/2015/07/09/Scala/%E3%80%90Scala%E3%80%91%E4%BD%BF%E7%94%A8Option%E3%80%81Either%E5%92%8CTry%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/" target="_blank" rel="external">使用Option、Either和Try处理数据交互</a><br><a href=""></a></li>
</ul>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding1354.gitcafe.io/" target="_blank" rel="external">GitCafe博客主页(http://jasonding1354.gitcafe.io/)</a><br><a href="http://jasonding1354.github.io/" target="_blank" rel="external">Github博客主页(http://jasonding1354.github.io/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>百度搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spark学习&quot;&gt;&lt;a href=&quot;#Spark学习&quot; class=&quot;headerlink&quot; title=&quot;Spark学习&quot;&gt;&lt;/a&gt;Spark学习&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jasonding1354.github.io/2015
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用maven构建scala项目</title>
    <link href="http://blog.jasonding.top/2016/08/08/Developer%20Kits/%E4%BD%BF%E7%94%A8maven%E6%9E%84%E5%BB%BAscala%E9%A1%B9%E7%9B%AE/"/>
    <id>http://blog.jasonding.top/2016/08/08/Developer Kits/使用maven构建scala项目/</id>
    <published>2016-08-08T02:28:05.000Z</published>
    <updated>2016-08-08T15:36:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建工程之前的准备"><a href="#创建工程之前的准备" class="headerlink" title="创建工程之前的准备"></a>创建工程之前的准备</h2><blockquote>
<ol>
<li>IntelliJ IDEA</li>
<li>Scala plugin for IDEA</li>
<li>Maven</li>
</ol>
</blockquote>
<h2 id="IDEA界面创建Scala的Maven项目"><a href="#IDEA界面创建Scala的Maven项目" class="headerlink" title="IDEA界面创建Scala的Maven项目"></a>IDEA界面创建Scala的Maven项目</h2><p><strong>1. 创建Maven工程</strong>，勾选右侧的<code>Create from archetype</code>选项，然后选中下方的<code>scala-archetype-simple</code>选项，如图所示：<br><img src="http://7nj1qk.com1.z0.glb.clouddn.com//maven/scala/mvn_scala_1" alt=""><br><strong>2. 填写相应的GroupId、ArtifactId内容</strong>，一般情况下GroupId是实际的项目名称，ArtifactId对应实际项目的一个模块，对应maven项目<br><strong>3. 配置Maven相关的环境</strong>，如图所示：<br><img src="http://7nj1qk.com1.z0.glb.clouddn.com//maven/scala/mvn_scala_2" alt=""><br><strong>4. 为项目取一个名字，然后完成项目创建</strong><br><strong>5. 右键Project，点击Add FrameWork Support，在打开的栏框中添加Scala支持</strong><br><strong>6. 修改项目的pom.xml文件</strong>，将<code>scala.version</code>改为依赖的Scala版本，然后针对pom.xml执行reimport操作，重新拉依赖</p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建工程之前的准备&quot;&gt;&lt;a href=&quot;#创建工程之前的准备&quot; class=&quot;headerlink&quot; title=&quot;创建工程之前的准备&quot;&gt;&lt;/a&gt;创建工程之前的准备&lt;/h2&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;IntelliJ IDEA&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Developer Kits" scheme="http://blog.jasonding.top/categories/Developer-Kits/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
      <category term="Maven" scheme="http://blog.jasonding.top/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>【函数式】纯函数与替代模型</title>
    <link href="http://blog.jasonding.top/2016/05/25/Functional%20Programming/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91%E7%BA%AF%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9B%BF%E4%BB%A3%E6%A8%A1%E5%9E%8B/"/>
    <id>http://blog.jasonding.top/2016/05/25/Functional Programming/【函数式】纯函数与替代模型/</id>
    <published>2016-05-25T09:26:40.000Z</published>
    <updated>2016-05-27T02:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>一个函数在程序执行的过程中除了根据输入参数给出运算结果之外没有其他的副作用影响，我们可以把这类函数称为“纯函数”。纯函数由于不依赖外部变量，使得给定函数输入其返回结果永远不变，比如整数的加法函数，它接收两个整数值并返回一个整数值，对于给定的两个整数值，它的返回值永远是相同的整数值。</p>
<h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>相对于非纯函数，它们带有副作用，这使得函数不仅简单返回一个值，还做了其他事情：</p>
<blockquote>
<ul>
<li>修改了一个变量</li>
<li>直接修改了数据结构</li>
<li>设置了一个对象的成员</li>
<li>抛出一个异常或以一个错误终止</li>
<li>打印到终端或读取用户的输入</li>
<li>读取或写入一个文件</li>
<li>在屏幕上绘画</li>
</ul>
</blockquote>
<p>像是执行IO、处理错误、修改数据都属于副作用，这些副作用可能导致我们编写的程序难以测试，进而容易产生bug。遵循函数式编程规范可以使编程更加模块化，由于纯函数模块化的特性，使得程序<strong>容易被测试、复用、并行化、泛化以及推导</strong>，这也减少了产生bug的可能。</p>
<p><strong>纯函数的使用将数据的创建过程和处理过程分离，通过把副作用推导程序的外层，来转换任何带有副作用的函数。对于函数式程序员而言，程序的实现应该有一个纯的内核和一层很薄的外围来处理副作用。</strong></p>
<h3 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h3><p>引用透明（referential transparency）的概念对纯函数进行形式化，符合引用透明的表达式都可以由它的结果所取代，而不改变该程序的含义。当调用一个函数时所传入的参数是引用透明的，冰鞋函数调用也是引用透明的，那么这个函数式一个纯函数。当传入函数的参数也是一个纯函数时，使得高阶函数的组合也是引用透明的，这有利于构建更加复杂的逻辑，而本身程序的计算结果是可以进行推断的，不用担心环境对程序的影响。</p>
<p>对于程序p，如果它包含的表达式e满足引用透明，所有的e都可以替换为它的运算结果而不会改变程序p的含义。假设存在一个函数f，若变大时f(x)对所有引用透明的表达式x也是引用透明的，那么这个f是一个纯函数。</p>
<h2 id="替代模型"><a href="#替代模型" class="headerlink" title="替代模型"></a>替代模型</h2><p>引用透明要求函数不论进行了任何操作都可以用它的返回值来代替。这种限制使得推导一个程序的求值变得简单而自然，称之为替代模型（substitution model）。如果表达式是引用透明的，可以想象计算过程就像在解代数方程。展开表达式的每一部分，使用指示对象替代变量，然后归约到最简单的形式。在这一过程中，每项都被等价值所替代，计算的过程就是一个又一个等价值所替代的过程。换句话说，引用透明使得程序具备了等式推理的能力。</p>
<p><strong>替代模型更容易推理，因为对运算的影响纯粹是局部的（只对那些赋值表达式产生影响），不需要先在内心模拟一系列状态的更新才理解这一段代码。只需要理解局部的推理，不必费心地去跟踪函数执行前后的状态变化，只用简单看一下函数的定义，把它替换成一个参数。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一小节，我们了解了纯函数的一些基本概念和其带来的好处。我们知道，纯函数时模块化的、可组合的，因为它从“对结果做什么”和“如果获取输入”中分离了计算本身的逻辑，就像一个黑盒子。对输入的获取只有一种方式：通过参数传给函数。输出也只是简单地将计算结果返回。把这些关注点分离开，计算也更容易被复用。我们可以复用这些逻辑，而不必担心输入或输出对整个上下文引起的副作用。</p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;纯函数&quot;&gt;&lt;a href=&quot;#纯函数&quot; class=&quot;headerlink&quot; title=&quot;纯函数&quot;&gt;&lt;/a&gt;纯函数&lt;/h2&gt;&lt;p&gt;一个函数在程序执行的过程中除了根据输入参数给出运算结果之外没有其他的副作用影响，我们可以把这类函数称为“纯函数”。纯函数由于不依赖外
    
    </summary>
    
      <category term="Functional Programming" scheme="http://blog.jasonding.top/categories/Functional-Programming/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
      <category term="Functional Programming" scheme="http://blog.jasonding.top/tags/Functional-Programming/"/>
    
  </entry>
  
  <entry>
    <title>【Scala】响应式编程思想</title>
    <link href="http://blog.jasonding.top/2016/05/15/Scala/%E3%80%90Scala%E3%80%91%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    <id>http://blog.jasonding.top/2016/05/15/Scala/【Scala】响应式编程思想/</id>
    <published>2016-05-15T02:58:00.000Z</published>
    <updated>2016-05-16T12:49:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为响应式编程"><a href="#何为响应式编程" class="headerlink" title="何为响应式编程"></a>何为响应式编程</h2><p><strong>响应式编程是一种面向数据流和变化传播的编程范式，数据更新是相关联的。</strong> 这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。<br>以响应式编程方式进行思考，意味着要放弃命令式且带状态的编程习惯，并且强迫你的大脑以一种不同的方式去工作。<br>响应式编程提高了代码的抽象层级，所以你可以只关注定义了业务逻辑的那些相互依赖的事件，而非纠缠于大量的实现细节。它可以简化项目，特别是处理嵌套回调的异步事件、复杂的列表过滤和变换，或时间相关问题。</p>
<h2 id="交互式编程与响应式编程"><a href="#交互式编程与响应式编程" class="headerlink" title="交互式编程与响应式编程"></a>交互式编程与响应式编程</h2><p>平时我们使用最多的便是“交互式（Interactive）”的编程方式，采用的是组件之间的相互调用来表现逻辑。例如，对象A向对象B请求数据并等待返回，待对象B完成并返还数据之后A才继续进行后面的操作。<br>响应式编程是一种基于“改变”的编程方式。例如在交互式编程中，A = B + C这样的表达式意味着将B与C之和赋给A，而此后B与C的改变都与A无关。而在响应式编程中，A会去“响应”B或C的变化，即一旦B或C改变之后，A的值也会随之变化。响应式编程的一个典型应用便是GoF23中的观察者模式。</p>
<h2 id="响应式系统模型"><a href="#响应式系统模型" class="headerlink" title="响应式系统模型"></a>响应式系统模型</h2><h3 id="Actor模型"><a href="#Actor模型" class="headerlink" title="Actor模型"></a>Actor模型</h3><p>Actor模型=数据+行为+消息。Actor模型内部的状态由自己的行为维护，外部线程不能直接调用对象的行为，必须通过消息才能激发行为，这样就保证Actor内部数据只有被自己修改。<br>Actor是一个个独立的实体，他们之间是毫无关联的。但是，他们可以通过消息来通信。一个Actor收到其他Actor的信息后，它可以根据需要作出各种相应。Actor的常见应用模式是处理大规模并发输入流：将具体工作分类给异步的工作节点，之后返回工作节点计算的结果。<br>Actor模型实际上并不是纯正的函数式编程模型。Receive方法返回Unit类型，这意味着在该方法中，所有事情都是通过副作用完成的。再者，只要需要，Actor模型便会允许使用可变状态，但这里要遵守一个规则，将状态封装在某个actor中，并确保所有状态的响应操作是线程安全的。<br>综上，Actor模型是处理大规模、高度可用、事件驱动应用程序的更为通用的方法。</p>
<h3 id="函数响应式编程（functional-reactive-programming，FRP）"><a href="#函数响应式编程（functional-reactive-programming，FRP）" class="headerlink" title="函数响应式编程（functional reactive programming，FRP）"></a>函数响应式编程（functional reactive programming，FRP）</h3><p>在函数响应式编程模型中，基于时间的状态需要通过某一系统传播到需要使用这些状态的代码中。当FRP模型中的某一状态发生变化时，你并不需要手动地对依赖这些变化的变量进行更新，与之相反，FRP会使用声明的方式描述数据元素之间的依赖关系，而FRP运行时则会负责状态的传播。因此，用户使用函数式声明语句和组合语法编写代码。</p>
<p>FRP基本上就是面向异步事件流的编程了，这个异步事件流（Stream）是一个按时间排序的事件序列。Stream是不可变的，任何操作都返回新的Stream，且它是一个Monad。</p>
<h3 id="响应式扩展（reactive-extensions，Rx）"><a href="#响应式扩展（reactive-extensions，Rx）" class="headerlink" title="响应式扩展（reactive extensions，Rx）"></a>响应式扩展（reactive extensions，Rx）</h3><p>响应式扩展这个概念最早出现在.net社区的Rx.net，一个提供处理异步事件的程序库，其核心概念是Observable，表示有限或者无限多个现在或者将来到达的事件。Observable提供了onNext，onError，onCompleted供开发者定制新元素到达，出现错误，或者流结束时的程序的行为。并提供了List上类似的操作，如map，filter，reduce，大大降低了异步事件编程的复杂度。<br>因为这些概念是如此的强大，以至于很多编程语言，如java，ruby，javascript很快就有了各自的reactvie extension。</p>
<p>Rx模型中的可观察序列代表事件流或其他数据源。通过将可观察序列与LINQ（language-integrated query，语言集成查询）库提供的查询操作符（组合器）拼接起来，Rx组成了异步程序。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Actor、FRP以及Rx都是基于事件的系统模型。FRP和Rx模型更像是一个处理各类事件流的管道系统，而Actor模型则像是一个包装各个组件进行交互的网络系统。尽管略有差异，但是这些模型都能够通过多种方式进行扩展。有一点可以断言，Actor模型健壮的错误处理策略，使得它对响应性提供的支持称为最强的支持。值得一提的是，尽管这些模型提高系统响应度的方式不同，但所有模型都致力于最大程度地减少阻塞。</p>
<h2 id="响应式系统须遵循的特征"><a href="#响应式系统须遵循的特征" class="headerlink" title="响应式系统须遵循的特征"></a>响应式系统须遵循的特征</h2><p>所有可伸缩、可恢复的响应式程序都应遵循这些特征：</p>
<blockquote>
<ul>
<li>react to events (events-driven)</li>
<li>react to load (scalable)</li>
<li>react to failures (resilient)</li>
<li>react to users (resonsive)</li>
</ul>
</blockquote>
<h3 id="消息传递或事件传递"><a href="#消息传递或事件传递" class="headerlink" title="消息传递或事件传递"></a>消息传递或事件传递</h3><p>响应式系统必须能对消息或事件进行响应，也可以称作是事件驱动（event-driven）的，这是最基本的要求。<br><strong>在传统的多线程系统中，多个线程通过共享同步状态进行通信，这种方式是强耦合的，难以进行组合；而响应式系统由弱耦合的事件句柄构成，事件传递是异步高效的，不会导致阻塞。</strong></p>
<h3 id="可灵活伸缩"><a href="#可灵活伸缩" class="headerlink" title="可灵活伸缩"></a>可灵活伸缩</h3><p>为了能够满足处理要求，响应式系统是可伸缩的系统。<strong>这意味着该系统能够通过向上扩展（scale up）的方式利用多核系统进行并行计算，通过向外扩展（scale out）的方式利用多个服务器节点。对于向上扩展而言，最重要的是减少可变状态的共享；而对于向外扩展而言，最重要的是要做到位置透明性（location transparency）来保证不同机器上的程序具有同样的功能，通过弹性（resilience）来处理不同服务器节点的错误和崩溃。</strong><br>理想状态下，为了能够动态响应不停变化的处理需求，系统应该根据当前需求动态的执行向上扩展，这种调整既包括增加处理资源，也包括自动回收资源。用这种方法，我们需要花费大量的精力才能对那些需要维护重要状态信息的服务进行向外扩展，而且这类系统也很难对状态信息进行“分片”和可靠的复制。</p>
<h3 id="容错可恢复"><a href="#容错可恢复" class="headerlink" title="容错可恢复"></a>容错可恢复</h3><p>随着系统不断变大，那些不常见的事件也会越来越频繁地出现在系统中。因此，错误（如异常这样的程序错误，宕机这样的硬件错误，网络连接这样的通信错误）也是需要考虑的头等大事。构造响应式系统时，必须在系统设计之初就考虑错误处理的问题，不断进行改造，以便能够在出现错误时优雅地恢复系统。所以常常需要弱耦合，对状态的封装和通用的监督系统的设计。</p>
<h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>响应式系统需要能够随时对服务请求进行响应，即使系统出现了错误的组件或是经历非常高的流量峰值，响应式也需要通过优雅降级的方式继续响应用户的请求。其需要建立在事件驱动、可扩展性和弹性架构这些属性之上。</p>
<h2 id="异步程序处理的思维转变"><a href="#异步程序处理的思维转变" class="headerlink" title="异步程序处理的思维转变"></a>异步程序处理的思维转变</h2><p>在异步事件处理程序中（比如GUI编程），常常通过回调函数来处理事件，这是建立在观察者模式的一种处理方式。这种方式有几点问题：</p>
<blockquote>
<ol>
<li>回调函数常常带有副作用，会导致回调函数和监听对象共享的变量（可变状态）发生改变</li>
<li>难以通过简单的监听对象实现更高的抽象，事件句柄很难进行组合</li>
<li>导致了“回调地狱（call-back hell）”，回调函数构成的网络难以理解和追踪</li>
</ol>
</blockquote>
<p>为了解决传统情况带来的困境，响应式编程从函数式编程之中借鉴了基本的元素和思想，得到了<strong>可组合的事件抽象（composable event abstractions）</strong> ：</p>
<blockquote>
<ol>
<li>事件是一等成员</li>
<li>事件常常表现为消息</li>
<li>事件处理程序同样是一等的</li>
<li>复杂的处理程序(complex handlers)可以由基础的程序组合而成</li>
</ol>
</blockquote>
<p>要学习响应式编程，我们首先要理解monad这个函数式设计模式，由于响应式编程并不是纯函数式的，故我们还需要将纯函数式编程和现实世界（包含了可变状态和非确定性计算）结合起来。有了上面两点做基础，我们还要学习使用future对事件进行抽象，使用observable对事件流进行抽象。最后再学习基于消息传递的系统架构——actor模型，以至于构建分布式的actor系统。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节中给出了响应式编程的基本概念，讨论了响应式系统模型和所遵循的特征。由于该方面的相关资料较为混乱，使得我在学习过程中难以把握一些概念的定界，待日后勤加实践，从Scala的并发系统和akka框架入手，加深对响应式编程的理解。</p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;何为响应式编程&quot;&gt;&lt;a href=&quot;#何为响应式编程&quot; class=&quot;headerlink&quot; title=&quot;何为响应式编程&quot;&gt;&lt;/a&gt;何为响应式编程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;响应式编程是一种面向数据流和变化传播的编程范式，数据更新是相关联的。&lt;/strong
    
    </summary>
    
      <category term="Scala" scheme="http://blog.jasonding.top/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>【Scala】Vector内部结构与内存共享原理</title>
    <link href="http://blog.jasonding.top/2016/05/11/Scala/%E3%80%90Scala%E3%80%91Vector%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.jasonding.top/2016/05/11/Scala/【Scala】Vector内部结构与内存共享原理/</id>
    <published>2016-05-11T11:48:34.000Z</published>
    <updated>2016-05-11T12:39:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scala不可变集合"><a href="#Scala不可变集合" class="headerlink" title="Scala不可变集合"></a>Scala不可变集合</h2><p>Scala不可变集合的设计目标是提供高效又安全的实现。这些集合中的大部分都是用高级技巧来在集合的不同版本之间“共享”内存。其中较长使用到的是Vector和List。<br>在一般的编程任务中，不可变集合有很多超出可变集合的优点。尤其重要的一点是不可变集合可以在多线程之中共享而无需加锁。</p>
<h2 id="Vector内部结构"><a href="#Vector内部结构" class="headerlink" title="Vector内部结构"></a>Vector内部结构</h2><p>Scala的Vector实现为一组嵌套数组，在分割和连接时非常有效率。适用于大部分通用算法，因为它有高效的下标计算能力，以及能够在使用像+:和++方法时共享大部分内部结构的能力。<br>Vector采用分支系数为32的树状数据结构，分支因子是每个父节点允许拥有的最大子节点的数目。其随机访问（搜索或修改）复杂度是log_32(N)，使用32位整数下标时在JVM上是个效率不错的小常量，即使对很大的N来说都近似一个常量。<br>Vector是个由元素的下标组成的前缀树（trie），前缀树是给定路径上的所有子节点功用某种形式的公共键值。我们可以根据任何下标的二进制形式得到查找路径，实现高效的元素查找。</p>
<h2 id="Vector复制过程中的结构共享原理"><a href="#Vector复制过程中的结构共享原理" class="headerlink" title="Vector复制过程中的结构共享原理"></a>Vector复制过程中的结构共享原理</h2><p>在实际应用中，为了保持变量的不可变性，对有用的集合进行复制通常是必要的。假设有一个包含100 000个元素的Vector，需要得到一个副本，并替换掉原Vector的第8个元素，此时如果构造一个全新的100 000个元素的Vector将会是极其低效的。<br>为了兼顾高效和不可变性，可以通过共享原始Vector中的不变部分，而以某种方式表示变化部分，那么就可以高效地“创建”新Vector了。这种思想称之为<strong>结构共享</strong>。</p>
<p>如果其他线程中的代码正在对原始Vector做其他不同的操作，对原始的Vector的复制不会影响该操作，因为原Vector没有被修改。这样，只要对旧版本有一个或多个引用，就可以创建一个Vector的“历史”版本。直到对旧版本的引用消失为止，旧版本才会被垃圾回收。</p>
<p>下面的图示解释了创建并修改副本过程中结构共享的原理：<br>使用#1来引用原树的根节点：<br><img src="http://7nj1qk.com1.z0.glb.clouddn.com/%40%2Fscala%2Fcollections%2Fvector1.jpg" alt=""><br>现在假设要在2和3之间插入2.5，要创建一个新的副本，我们并不需要修改原来的树结构，而是创建新树。<br>值得注意的是，原来的树（#1）仍然存在，但我们又创建了新的根（#2）和新的节点。创建新的树共享重用了原来的大部分节点，这样有助于降低修改集合的开销。<br><img src="http://7nj1qk.com1.z0.glb.clouddn.com/%40%2Fscala%2Fcollections%2Fvector2.jpg" alt=""></p>
<h2 id="Vector查找原理"><a href="#Vector查找原理" class="headerlink" title="Vector查找原理"></a>Vector查找原理</h2><p>Scala的Vector集合非常类似于一个分支系数为32的下标前缀树。关键区别在于Vector用一个数组来表示分支。这使整个结构变成数组的数组（嵌套数组）。<br>下图是分支系数为2的二进制Vector：<br><img src="http://7nj1qk.com1.z0.glb.clouddn.com/%40%2Fscala%2Fcollections%2Fvector3.jpg" alt=""><br>其中有三个基本素组：display0、display1和display2.这些数组代表原始前缀树的深度。每个显示元素（display element）都是一个更深一层的的嵌套数组（display0是元素的数组，display1是数组的数组，display2是数组的数组的数组）。<strong>查找集合元素的步骤是先判断其深度，然后用跟前缀树一样的方式确定元素所在的数组</strong>。比如找数字4，其深度为2，所以先选择display2数组，4的二进制形式100，所以外层数组是下标为1的位置上，中层数组下标为0，最后4就位于结果数组的下标0的位置上。</p>
<p>二进制前缀树根据下标随机取值的复杂度是log_2(n)，Scala的Vector的分支系数为32，那么访问任何元素的时间复杂度是log_32(n)，对32位的下标也就大约是7，对64位大约是13.而对于较小的集合，排序的开销也会降低，所以访问速度会更快。所以随机访问的时间复杂度与前缀树的大小成正比。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Scala的Vector为32分支，这除了带来查找时间和修改时间可以随集合大小伸缩外，它还提供了不错的缓存一致性，因为集合里相近的元素有很大可能位于同一个内存数组里。其高效结合不可变所带来的线程安全使之成为库里最强大的有序集合。<br>Scala的序列类型中Vector和List数据结构都是很常用的，Vector的所有操作都是O(1)（常数时间），而List对于那些需要访问头部以为元素的操作都需要O(n)操作，所以只在频繁执行头尾分解的情况下，推荐使用List。</p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Scala不可变集合&quot;&gt;&lt;a href=&quot;#Scala不可变集合&quot; class=&quot;headerlink&quot; title=&quot;Scala不可变集合&quot;&gt;&lt;/a&gt;Scala不可变集合&lt;/h2&gt;&lt;p&gt;Scala不可变集合的设计目标是提供高效又安全的实现。这些集合中的大部分都是
    
    </summary>
    
      <category term="Scala" scheme="http://blog.jasonding.top/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>【Scala-ML】使用Scala构建机器学习工作流</title>
    <link href="http://blog.jasonding.top/2016/03/19/Scala-ML/%E3%80%90Scala-ML%E3%80%91%E4%BD%BF%E7%94%A8Scala%E6%9E%84%E5%BB%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>http://blog.jasonding.top/2016/03/19/Scala-ML/【Scala-ML】使用Scala构建机器学习工作流/</id>
    <published>2016-03-19T08:23:09.000Z</published>
    <updated>2016-03-21T12:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在这一小节中，我将介绍基于数据（函数式）的方法来构建数据应用。这里会介绍monadic设计来创建动态工作流，利用依赖注入这样的面向对象技巧来构建可配置的计算工作流。</p>
<h2 id="建模过程"><a href="#建模过程" class="headerlink" title="建模过程"></a>建模过程</h2><p>在统计学和概率论中，一个模型通过描述从一个系统中观察到的数据来表达任何形式的不确定性，模型使得我们可以用来推断规则，进行预测，从数据中学习有用的东西。<br>对于有经验的Scala程序员而言，模型常常和monoid联系起来。monoid是一些观测的集合，其中的操作是实现模型所需的函数。</p>
<p><strong>关于模型的特征</strong><br>模型特征的选择是从可用变量中发现最小集合来构建模型的过程。数据中常常包含多余和不相干的特征，这些多余特征并不能提供任何有用信息，所以需要通过特征选择将有用的特征挑选出来。<br>特征选择包含两个具体步骤</p>
<blockquote>
<ul>
<li>搜索新的特征子集</li>
<li>通过某种评分机制来评估特征子集</li>
</ul>
</blockquote>
<p>观测数据是一组隐含特征（也称为隐含变量，latent variables）的间接测量，他们可能是噪声，也可能包含高度的相关性和冗余。直接使用原始观测进行预测任务常常得到不准确的结果，使用从观测数据提取的所有特征又带来了计算代价。特征抽取可以通过去除冗余或不相关的特征来减少特征数量或维度。</p>
<h2 id="设计工作流"><a href="#设计工作流" class="headerlink" title="设计工作流"></a>设计工作流</h2><p>首先，所选的数学模型是从原始输入数据中抽取知识的，那么模型的选择中需要考虑以下几个方面：</p>
<blockquote>
<ul>
<li>业务需求，比如预测结果的准确度</li>
<li>训练数据和算法的可用性</li>
<li>专业领域的相关知识</li>
</ul>
</blockquote>
<p>然后，从工程角度出发，需要选择一种计算调度框架来处理数据，这需要考虑以下几个方面：</p>
<blockquote>
<ul>
<li>可用资源，如CPU、内存、IO带宽</li>
<li>实现策略，如迭代和递归计算</li>
<li>响应整个过程的需求，如计算时间、中间结果的显示</li>
</ul>
</blockquote>
<p>下面的图标给出了计算模型的工作流程：<br><img src="http://7nj1qk.com1.z0.glb.clouddn.com/%40%2Fscala%2Fml%2Fcomputational_model.jpg" alt=""><br>在这个流程图中，下游的数据转换（data transformation）的参数需要根据上游数据转换的输出进行配置，Scala的高阶函数非常适合实现可配置的数据转换。</p>
<h2 id="计算框架"><a href="#计算框架" class="headerlink" title="计算框架"></a>计算框架</h2><p>创建足够灵活和可重用的框架的目的是为了更好地适应不同工作流程，支持各种类型的机器学习算法。<br>Scala通过特质（traits）语法实现了丰富的语言特性，可以通过下面的设计层级来构建复杂的程序框架：<br><img src="http://7nj1qk.com1.z0.glb.clouddn.com/%40%2Fscala%2Fml%2Fhierarchical_design.jpg" alt=""></p>
<h3 id="管道操作符（The-pipe-operator）"><a href="#管道操作符（The-pipe-operator）" class="headerlink" title="管道操作符（The pipe operator）"></a>管道操作符（The pipe operator）</h3><p>数据转换是对数据进行分类、训练验证模型、结果可视化等每个步骤环节的基础。定义一个符号，表示不同类型的数据转换，而不暴露算法实现的内部状态。而管道操作符就是用来表示数据转换的。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PipeOperator</span>[-<span class="type">T</span>, +<span class="type">U</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">|&gt;</span></span>(data: <span class="type">T</span>): <span class="type">Option</span>[<span class="type">U</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>|&gt;</code>操作符将类型为T的数据转换成类型为U的数据，返回一个Option来处理中间的错误和异常。</p>
<h3 id="单子化数据转换（Monadic-data-transformation）"><a href="#单子化数据转换（Monadic-data-transformation）" class="headerlink" title="单子化数据转换（Monadic data transformation）"></a>单子化数据转换（Monadic data transformation）</h3><p>接下来需要创建单子化的设计（monadic design）来实现管道操作（pipe operator）。通过单子化设计来包装类<code>_FCT</code>。<code>_FCT</code>类的方法代表了传统Scala针对集合的高阶函数子集。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FCT</span>[+<span class="type">T</span>](<span class="params">val _fct: <span class="type">T</span></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>](c: <span class="type">T</span> =&gt; <span class="type">U</span>): _FCT[<span class="type">U</span>] = <span class="keyword">new</span> _FCT[<span class="type">U</span>]( c(_fct))</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>](f: <span class="type">T</span> =&gt;_FCT[<span class="type">U</span>]): _FCT[<span class="type">U</span>] = f(_fct)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">T</span> =&gt;<span class="type">Boolean</span>): _FCT[<span class="type">T</span>] =</div><div class="line">  <span class="keyword">if</span>( p(_fct) ) <span class="keyword">new</span> _FCT[<span class="type">T</span>](_fct) <span class="keyword">else</span> zeroFCT(_fct)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reduceLeft</span></span>[<span class="type">U</span>](f: (<span class="type">U</span>,<span class="type">T</span>) =&gt; <span class="type">U</span>)(<span class="keyword">implicit</span> c: <span class="type">T</span>=&gt; <span class="type">U</span>): <span class="type">U</span> =</div><div class="line">  f(c(_fct),_fct)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">U</span>](zero: <span class="type">U</span>)(f: (<span class="type">U</span>, <span class="type">T</span>) =&gt; <span class="type">U</span>)(<span class="keyword">implicit</span> c: <span class="type">T</span>=&gt; <span class="type">U</span>): <span class="type">U</span> =</div><div class="line">  f(c(_fct), _fct)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = p(_fct)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后，<code>Transform</code>类将<code>PipeOperator</code>实例作为参数输入，自动调用其操作符，像这样：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transform</span>[-<span class="type">T</span>, +<span class="type">U</span>](<span class="params">val op: <span class="type">PipeOperator</span>[<span class="type">T</span>, <span class="type">U</span>]</span>) <span class="keyword">extends</span> <span class="title">_FCT</span>[<span class="type">Function</span>[<span class="type">T</span>, <span class="type">Option</span>[<span class="type">U</span>]]](<span class="params">op.|&gt;</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">|&gt;</span></span>(data: <span class="type">T</span>): <span class="type">Option</span>[<span class="type">U</span>] = _fct(data)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也许你会对数据转换<code>Transform</code>的单子化表示背后的原因表示怀疑，毕竟本来可以通过<code>PipeOperator</code>的实现来创建任何算法。<br>原因是<code>Transform</code>含有丰富的方法，使得开发者可以创建丰富的工作流。<br>下面的代码片段描述的是使用单子化方法来进行数据转换组合：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> op = <span class="keyword">new</span> <span class="type">PipeOperator</span>[<span class="type">Int</span>, <span class="type">Double</span>] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">|&gt;</span> </span>(n: <span class="type">Int</span>):<span class="type">Option</span>[<span class="type">Double</span>] =<span class="type">Some</span>(<span class="type">Math</span>.sin(n.toDouble))</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span></span>(f: <span class="type">Int</span> =&gt;<span class="type">Option</span>[<span class="type">Double</span>]): (<span class="type">Int</span>=&gt; <span class="type">Long</span>) = &#123;</div><div class="line">  (n: <span class="type">Int</span>) =&gt; &#123;</div><div class="line">    f(n) <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; x.toLong</div><div class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="number">-1</span>L</div><div class="line">    &#125;   </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> gof = <span class="keyword">new</span> <span class="type">Transform</span>[<span class="type">Int</span>,<span class="type">Double</span>](op).map(g(_))</div></pre></td></tr></table></figure></p>
<p>这里使用函数g作为现有的数据转换来扩展op。</p>
<h3 id="依赖注入（Dependency-injection）"><a href="#依赖注入（Dependency-injection）" class="headerlink" title="依赖注入（Dependency injection）"></a>依赖注入（Dependency injection）</h3><p>一个由可配置的数据转换构成的工作流在其不同的流程阶段都需要动态的模块化。蛋糕模式（Cake Pattern）是使用混入特质（mix-in traits）来满足可配置计算工作流的一种高级类组合模式。<br>Scala通过特质这一语法特性使得开发者能够使用一种灵活的、可重用的方法来创建和管理模块，特质是可嵌套的、可混入类中的、可堆叠的、可继承的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> myApp = <span class="keyword">new</span> <span class="type">Classification</span> <span class="keyword">with</span> <span class="type">Validation</span> <span class="keyword">with</span> <span class="type">PreProcessing</span> &#123;</div><div class="line">  <span class="keyword">val</span> filter = ..</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> myApp = <span class="keyword">new</span> <span class="type">Clustering</span> <span class="keyword">with</span> <span class="type">Validation</span> <span class="keyword">with</span> <span class="type">PreProcessing</span> &#123;</div><div class="line">  <span class="keyword">val</span> filter = ..</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于上面两个应用来说，都需要数据的预处理和验证模块，在代码中都重复定义了filter方法，使得代码重复、缺乏灵活性。当特质在组合中存在依赖性时，这个问题凸现出来。</p>
<blockquote>
<p><strong>混入的线性化</strong><br>在混入的特质中，方法调用遵循从右到左的顺序：</p>
<ul>
<li>trait B extends A</li>
<li>trait C extends A</li>
<li>class M extends N with C with B<br>Scala编译器按照<code>M =&gt; B =&gt; C =&gt; A =&gt; N</code>的线性顺序来实现</li>
</ul>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PreProcessingWithValidation</span> <span class="keyword">extends</span> <span class="title">PreProcessing</span> </span>&#123;</div><div class="line">  self: <span class="type">Validation</span> =&gt;</div><div class="line">  <span class="keyword">val</span> filter = ..</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> myApp = <span class="keyword">new</span> <span class="type">Classification</span> <span class="keyword">with</span> <span class="type">PreProcessingWithValidation</span> &#123;</div><div class="line">  <span class="keyword">val</span> validation: <span class="type">Validation</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在PreProcessingWithValidation中使用self类型来解决上述问题。<br>（tips：原书的内容在这里我没怎么搞清楚，不知道是通过自身类型混入了Validation后filter方法具体是怎么实现的，以及实例化Classification时混入PreProcessingWithValidation难道不需要混入Validation吗？我表示疑问）</p>
<h2 id="工作流模块"><a href="#工作流模块" class="headerlink" title="工作流模块"></a>工作流模块</h2><p>由PipeOperator定义的数据转换动态地嵌入了通过抽象val定义的模块中，下面我们定义工作流的三个阶段：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PreprocModule</span>[-<span class="type">T</span>, +<span class="type">U</span>] </span>&#123; <span class="keyword">val</span> preProc: <span class="type">PipeOperator</span>[<span class="type">T</span>, <span class="type">U</span>] &#125;</div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ProcModule</span>[-<span class="type">T</span>, +<span class="type">U</span>] </span>&#123; <span class="keyword">val</span> proc: <span class="type">PipeOperator</span>[<span class="type">T</span>, <span class="type">U</span>] &#125;</div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PostprocModule</span>[-<span class="type">T</span>, +<span class="type">U</span>] </span>&#123; <span class="keyword">val</span> postProc: <span class="type">PipeOperator</span>[<span class="type">T</span>, <span class="type">U</span>] &#125;</div></pre></td></tr></table></figure></p>
<p>上面的特质（模块）仅包含一个抽象值，蛋糕模式的一个特点是用模块内部封装的类型初始化抽象值来执行严格的模块化：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ProcModule</span>[-<span class="type">T</span>, +<span class="type">U</span>] </span>&#123;</div><div class="line">  <span class="keyword">val</span> proc: <span class="type">PipeOperator</span> [<span class="type">T</span>, <span class="type">U</span>]</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Classification</span>[-<span class="type">T</span>, +<span class="type">U</span>] <span class="keyword">extends</span> <span class="title">PipeOperator</span> [<span class="type">T</span>,<span class="type">U</span>] </span>&#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构建框架的一个目的是允许开发者可以从任何工作流中独立创建数据转换（继承自PipeOperator）。</p>
<h2 id="工作流工厂"><a href="#工作流工厂" class="headerlink" title="工作流工厂"></a>工作流工厂</h2><p>接下来就是将不同的模块写入一个工作流中，通过上一小节中的三个特质的堆叠作为自身引用来实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkFlow</span>[<span class="type">T</span>, <span class="type">U</span>, <span class="type">V</span>, <span class="type">W</span>] </span>&#123;</div><div class="line">  self: <span class="type">PreprocModule</span>[<span class="type">T</span>,<span class="type">U</span>] <span class="keyword">with</span> <span class="type">ProcModule</span>[<span class="type">U</span>,<span class="type">V</span>] <span class="keyword">with</span> <span class="type">PostprocModule</span>[<span class="type">V</span>,<span class="type">W</span>] =&gt;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">|&gt;</span> </span>(data: <span class="type">T</span>): <span class="type">Option</span>[<span class="type">W</span>] = &#123;</div><div class="line">    preProc |&gt; data <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Some</span>(input) =&gt; &#123;</div><div class="line">        proc |&gt; input <span class="keyword">match</span> &#123;</div><div class="line">          <span class="keyword">case</span> <span class="type">Some</span>(output) =&gt; postProc |&gt; output</div><div class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt; &#123; … &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; &#123; … &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面介绍如何具体地实现一个工作流。<br>首先通过继承PipeOperator来定义集中数据转换：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sampler</span>(<span class="params">val samples: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">PipeOperator</span>[<span class="type">Double</span> =&gt; <span class="type">Double</span>, <span class="type">DblVector</span>] </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">|&gt;</span> </span>(f: <span class="type">Double</span> =&gt; <span class="type">Double</span>): <span class="type">Option</span>[<span class="type">DblVector</span>] =</div><div class="line">  <span class="type">Some</span>(<span class="type">Array</span>.tabulate(samples)(n =&gt; f(n.toDouble/samples)) )</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Normalizer</span> <span class="keyword">extends</span> <span class="title">PipeOperator</span>[<span class="type">DblVector</span>, <span class="type">DblVector</span>] </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">|&gt;</span> </span>(data: <span class="type">DblVector</span>): <span class="type">Option</span>[<span class="type">DblVector</span>] =</div><div class="line">  <span class="type">Some</span>(<span class="type">Stats</span>[<span class="type">Double</span>](data).normalize)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reducer</span> <span class="keyword">extends</span> <span class="title">PipeOperator</span>[<span class="type">DblVector</span>, <span class="type">Int</span>] </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">|&gt;</span> </span>(data: <span class="type">DblVector</span>): <span class="type">Option</span>[<span class="type">Int</span>] =</div><div class="line">  <span class="type">Range</span>(<span class="number">0</span>, data.size) find(data(_) == <span class="number">1.0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://7nj1qk.com1.z0.glb.clouddn.com/%40%2Fscala%2Fml%2Fworkflow_factory.jpg" alt=""><br>工作流工厂由这个UML类图描述。<br>最终通过动态地初始化抽象值preProc、proc和postProc来实例化工作流。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> dataflow = <span class="keyword">new</span> <span class="type">Workflow</span>[<span class="type">Double</span> =&gt; <span class="type">Double</span>, <span class="type">DblVector</span>, <span class="type">DblVector</span>, <span class="type">Int</span>]</div><div class="line">  <span class="keyword">with</span> <span class="type">PreprocModule</span>[<span class="type">Double</span> =&gt; <span class="type">Double</span>, <span class="type">DblVector</span>]</div><div class="line">  <span class="keyword">with</span> <span class="type">ProcModule</span>[<span class="type">DblVector</span>, <span class="type">DblVector</span>]</div><div class="line">  <span class="keyword">with</span> <span class="type">PostprocModule</span>[<span class="type">DblVector</span>, <span class="type">Int</span>] &#123;</div><div class="line">    <span class="keyword">val</span> preProc: <span class="type">PipeOperator</span>[<span class="type">Double</span> =&gt; <span class="type">Double</span>,<span class="type">DblVector</span>] = <span class="keyword">new</span> <span class="type">Sampler</span>(<span class="number">100</span>) <span class="comment">//1</span></div><div class="line">    <span class="keyword">val</span> proc: <span class="type">PipeOperator</span>[<span class="type">DblVector</span>,<span class="type">DblVector</span>]= <span class="keyword">new</span> <span class="type">Normalizer</span> <span class="comment">//1</span></div><div class="line">    <span class="keyword">val</span> postProc: <span class="type">PipeOperator</span>[<span class="type">DblVector</span>,<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Reducer</span><span class="comment">//1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">dataflow |&gt; ((x: <span class="type">Double</span>) =&gt; <span class="type">Math</span>.log(x+<span class="number">1.0</span>)+<span class="type">Random</span>.nextDouble) <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Some</span>(index) =&gt; …</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Scala for Machine Learning》Chapter 2</p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在这一小节中，我将介绍基于数据（函数式）的方法来构建数据应用。这里会介绍monadic设计来创建动态工作流，利用依赖注入这样的面向对象技巧来
    
    </summary>
    
      <category term="Scala-ML" scheme="http://blog.jasonding.top/categories/Scala-ML/"/>
    
    
      <category term="Machine Learning" scheme="http://blog.jasonding.top/tags/Machine-Learning/"/>
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>【Scala类型系统】自身类型self type</title>
    <link href="http://blog.jasonding.top/2016/03/15/Scala/%E3%80%90Scala%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E3%80%91%E8%87%AA%E8%BA%AB%E7%B1%BB%E5%9E%8Bself-type/"/>
    <id>http://blog.jasonding.top/2016/03/15/Scala/【Scala类型系统】自身类型self-type/</id>
    <published>2016-03-15T12:30:42.000Z</published>
    <updated>2016-03-18T06:38:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>特质可以要求混入它的类扩展自另一个类型，但是当使用自身类型（self type）的声明来定义特质时（<code>this: ClassName =&gt;</code>），这样的特质只能被混入给定类型的子类当中。<br>如果尝试将该特质混入不符合自身类型所要求的类时，就会报错。</p>
<p>从技术角度上看，自身类型是在类中提到this时，对于this的假设性类型。从实用角度上看，自身类型指定了对于特质能够混入的具体类的需求。如果你的特质仅用于混入另一个或几个特质，那么可以指定那些假设性的特质。</p>
<h2 id="自身类型在依赖注入的应用"><a href="#自身类型在依赖注入的应用" class="headerlink" title="自身类型在依赖注入的应用"></a>自身类型在依赖注入的应用</h2><p>在通过组件构建大型系统，而每个组件都有不同的实现的时候，我们需要将组件的不同选择组装起来。通常组件之间存在某种依赖关系，比如，数据访问组件可能会依赖日志功能。<br>每个组件都描述了它所依赖的其他组件的接口，而对实际组件实现的引用是在应用程序被组件起来的时候“注入”的。<br>对于Scala来说，可以通过特质和自身类型达到简单的依赖注入的效果。</p>
<h3 id="自身类型实现依赖注入"><a href="#自身类型实现依赖注入" class="headerlink" title="自身类型实现依赖注入"></a>自身类型实现依赖注入</h3><p>对于日志功能<code>trait Logger {def log(msg: String)}</code>，它有两个实现：<code>ConsoleLogger</code>和<code>FileLogger</code>。<br>用户认证特质有对日志功能的依赖，用于记录认证失败：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Auth</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>: <span class="type">Logger</span> =&gt;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span></span>(id: <span class="type">String</span>, password: <span class="type">String</span>): <span class="type">Boolean</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>应用逻辑依赖于上述两个特质，如此定义:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">App</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>: <span class="type">Logger</span> <span class="keyword">with</span> <span class="type">Auth</span> =&gt;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们可以组装应用，<code>object MyApp extends App with FileLogger(&quot;test.log&quot;) with MockAuth(&quot;users.txt&quot;)</code>。这里将组件黏合成了一个大类型。</p>
<h3 id="蛋糕模式实现组件配置设计"><a href="#蛋糕模式实现组件配置设计" class="headerlink" title="蛋糕模式实现组件配置设计"></a>蛋糕模式实现组件配置设计</h3><p>蛋糕模式可以给出更好的设计，对每个服务都提供一个组件特质。<br>组件特质包括：</p>
<blockquote>
<ul>
<li>任何所依赖的组件，以自身类型表述</li>
<li>描述服务接口的特质</li>
<li>抽象的val，该val将被初始化成服务的一个实例</li>
<li>可以有选择地包含服务接口的实现</li>
</ul>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">LoggerComponent</span> </span>&#123;</div><div class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;...&#125;</div><div class="line">  <span class="keyword">val</span> logger: <span class="type">Logger</span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span>(<span class="params">file: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;...&#125;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AuthComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>: <span class="type">LoggerComponent</span> =&gt; <span class="comment">//自身类型使得可以访问日志器</span></div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Auth</span> </span>&#123;...&#125;</div><div class="line">  <span class="keyword">val</span> auth: <span class="type">Auth</span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MockAuth</span>(<span class="params">file: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Auth</span> </span>&#123;...&#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码中，我们使用自身类型表示认证组件对日志器组件的依赖。</p>
<p>通过在程序中进行组件配置可以让编译器帮助我们校验模块间的依赖关系：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">AppComponents</span> <span class="keyword">extends</span> <span class="title">LoggerComponent</span> <span class="keyword">with</span> <span class="title">AuthComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">val</span> logger = <span class="keyword">new</span> <span class="type">FileLogger</span>(<span class="string">"test.log"</span>)</div><div class="line">  <span class="keyword">val</span> auth = <span class="keyword">new</span> <span class="type">MockAuth</span>(<span class="string">"user.txt"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Scala编程<br>快学Scala</p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;特质可以要求混入它的类扩展自另一个类型，但是当使用自身类型（self type）的声明来定义特质时（&lt;code&gt;this: ClassNam
    
    </summary>
    
      <category term="Scala" scheme="http://blog.jasonding.top/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>【Scala-ML】如何利用Scala构建并行机器学习系统</title>
    <link href="http://blog.jasonding.top/2016/03/12/Scala-ML/%E3%80%90Scala-ML%E3%80%91%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Scala%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%A1%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F/"/>
    <id>http://blog.jasonding.top/2016/03/12/Scala-ML/【Scala-ML】如何利用Scala构建并行机器学习系统/</id>
    <published>2016-03-12T03:16:50.000Z</published>
    <updated>2016-03-17T14:41:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在学习Scala的过程中，我发现其在构建大规模分布式计算系统上有与生俱来的特质。其丰富的类型系统可以帮助编程设计提供很好的信息隐藏和抽象，其monoids和monads概念利用Scala高阶函数实现计算并行和数据处理流水线，其Actor系统帮助编写可伸缩性的应用程序，其实现特定领域语言的优势帮助开发用户很好克服不同语言的障碍。<br>虽然以上Scala优点说起来不会感同身受，但这可以作为我学习的一大动力，让我开始尝试编写并行机器学习系统。<br>在学习过程中，我主要参考《Scala for Machine Learning》一书和相关网上的资料。希望这些分享能帮助自己学习，也更好的服务有兴趣的读者。</p>
<h2 id="为何使用Scala构建机器学习系统"><a href="#为何使用Scala构建机器学习系统" class="headerlink" title="为何使用Scala构建机器学习系统"></a>为何使用Scala构建机器学习系统</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>Monoids和Monads是函数式编程的重要概念。<br>Monoids定义了在具有闭包性质（property of closure）的数据集上的二元操作op，恒等操作（identity operation）和结合性（associativity）。<br>下面是代码描述：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">T</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a: <span class="type">T</span>, b: <span class="type">T</span>): <span class="type">T</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Monoids具有结合性的操作。假设ts1、ts2、ts3是三个时间序列，该性质保证ts1+(ts2+ts3) = (ts1+ts2)+ts3。Monoid的结合性对于计算流的并行化是很关键的。</p>
<p>Monads可以被认为是容器的结构，它是Monoids的推广。像是Scala标准库中的List，Map等集合被设计成monads的结构。<br>Monads提供了以下的功能：1. 创建集合； 2. 对集合的元素进行转换； 3. 压平嵌套的集合。<br>下面是Scala代码描述：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">M</span>[_]] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](a: <span class="type">T</span>): <span class="type">M</span>[<span class="type">T</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">T</span>, <span class="type">U</span>](m: <span class="type">M</span>[<span class="type">T</span>])(f: <span class="type">T</span>=&gt;<span class="type">M</span>[<span class="type">U</span>]): <span class="type">M</span>[<span class="type">U</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Monads允许集合或者容器连接起来产生一个工作流，该性质可以应用在任何科学计算中。</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>Actors系统使得Scala编程变得可伸缩、可扩展。Actors作为协程（coroutines），通过异步消息进行通信，管理底层的线程池。<br>机器学习的工作流被实现成一系列的计算任务，这些任务包含了Scala的高阶方法（如flatMap,map,fold,reduce,collect,join,filter）对数据集合的操作，Scala允许actors集群对这些数据进行分割来完成计算任务。Scala还支持本地或远程的actor之间进行消息分发和消息路由。<br><img src="http://7nj1qk.com1.z0.glb.clouddn.com/%40%2Fscala%2Fml%2Fdistributed_computation_workflow.jpg" alt=""><br>上图中，主节点作为控制器，管理和调度四步任务。这些具体的任务通过Scala的actors实现的多个工作节点执行。主节点通过和工作节点交换消息来管理工作流的执行状态，负责可靠性。通过监督actors的层次结构来实现计算任务的高可用性。</p>
<h3 id="可配置性"><a href="#可配置性" class="headerlink" title="可配置性"></a>可配置性</h3><p>Scala支持依赖注入（dependency injection），通过抽象变量（abstract variables）、自引用成分（self-referenced composition）和可堆叠的特质（stackable traits）的组合来实现。最常用的依赖注入的模式成为cake pattern，该模式在构建动态计算工作流中经常用到。</p>
<h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>Scala内嵌了领域专用语言（Domain Specific Languages，DSL）。DSLs是在Scala原生库上建立的语法层，DSLs允许软件开发者抽象计算细节，更好让使用者理解。DSLs最有名的应用案例就是在Matlab中的语法形式。</p>
<h2 id="计算工作流"><a href="#计算工作流" class="headerlink" title="计算工作流"></a>计算工作流</h2><p><img src="http://7nj1qk.com1.z0.glb.clouddn.com/%40%2Fscala%2Fml%2Fdata_flow.jpg" alt=""><br>一个计算工作流（computational workflow）可以分为以下几个步骤：</p>
<ol>
<li>从文件或数据库中载入数据集</li>
<li>将数据集进行分割，用于并行的数据处理</li>
<li>运用过滤技术、方差分析等进行数据预处理</li>
<li><p>应用机器学习模型</p>
<blockquote>
<p>在使用训练数据进行分析的过程还需要一些具体的处理：</p>
<ul>
<li>从清洗的输入数据中选择训练集、测试集、验证集</li>
<li>抽取关键特征、利用聚类技术从一组相似观测中简历亲近关系</li>
<li>减少特征数量，避免训练数据过拟合</li>
<li>重复进行多次上述步骤来验证模型和调整模型</li>
<li>将模型进行持久化，用于新观测数据的预测和处理</li>
</ul>
</blockquote>
</li>
<li><p>评估模型表现</p>
</li>
</ol>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding1354.github.io/" target="_blank" rel="external">Github博客主页(http://jasonding1354.github.io/)</a><br><a href="http://jasonding1354.gitcafe.io/" target="_blank" rel="external">GitCafe博客主页(http://jasonding1354.gitcafe.io/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在学习Scala的过程中，我发现其在构建大规模分布式计算系统上有与生俱来的特质。其丰富的类型系统可以帮助编程设计提供很好的信息隐藏和抽象，其
    
    </summary>
    
      <category term="Scala-ML" scheme="http://blog.jasonding.top/categories/Scala-ML/"/>
    
    
      <category term="Machine Learning" scheme="http://blog.jasonding.top/tags/Machine-Learning/"/>
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>【Scala】Cake模式和依赖注入</title>
    <link href="http://blog.jasonding.top/2016/03/11/Scala/%E3%80%90Scala%E3%80%91Cake%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>http://blog.jasonding.top/2016/03/11/Scala/【Scala】Cake模式和依赖注入/</id>
    <published>2016-03-11T12:50:27.000Z</published>
    <updated>2016-03-16T06:24:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="依赖注入（Dependency-Injection）和控制反转（Inversion-of-Control）"><a href="#依赖注入（Dependency-Injection）和控制反转（Inversion-of-Control）" class="headerlink" title="依赖注入（Dependency Injection）和控制反转（Inversion of Control）"></a>依赖注入（Dependency Injection）和控制反转（Inversion of Control）</h2><p><a href="http://martinfowler.com/articles/injection.html" target="_blank" rel="external">Dependency Injection &amp; Inversion of Control</a>是Martin Fowler在2004年所提出來的一个概念，Martin Fowler在这篇文章中指出，DI可以有三种形式来实现。这观念以后有Spring项目和Google实现出来，变成了Java Enterprise应用中不可或缺的一部分。</p>
<p>控制反转是一个重要的面向对象编程的法则来<strong>削减计算机程序的耦合问题</strong>。控制反转一般分为两个类型，依赖注入（Dependency Injection）和依赖查找（Dependency Lookup）。依赖注入应用广泛。</p>
<blockquote>
<p>许多应用程序都是由两个或更多的类通过彼此的合作来实现业务逻辑，这使得每个对象都需要与其合作的对象（也就是它做依赖的对象）的引用。如果这个获取过程要靠自身实现，那么这将导致代码高度耦合并且难以测试。<br>应用控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用，传递给它。也可以说，依赖被注入到对象中。所以，控制反转是关于一个对象如何获取它所依赖的对象的引用——这个责任的反转。</p>
</blockquote>
<p>IoC模式，系统中通过引入实现了IoC模式的IoC容器，即可由IoC容器来管理对象的生命周期、依赖关系等，从而使得应用程序的配置和依赖性规范与实际的应用程序代码分开。其中一个特点就是通过文本的配置文件进行应用程序组件间依赖关系的配置，而不用重新修改并编译具体的代码。<br>对于Java程序而言，IoC模式可以看做是工厂模式的升华，可以把IoC看做是一个大工厂，只不过大工厂要生成的对象都是在XML文件中给出定义的，然后利用Java的反射编程，根据XML中给出的类名生成相应的对象。从实现来看，IoC是把以前的工厂方法里写死的对象生成代码，改变为由XML文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p>
<h2 id="Scala中的蛋糕模式（cake-pattern）"><a href="#Scala中的蛋糕模式（cake-pattern）" class="headerlink" title="Scala中的蛋糕模式（cake pattern）"></a>Scala中的蛋糕模式（cake pattern）</h2><p>依赖注入一般需要三个组成部分：</p>
<blockquote>
<ol>
<li>依赖消费者</li>
<li>依赖项的声明（依赖消费者需要的依赖项）</li>
<li>将对象引用或类型注入到依赖消费者的方法</li>
</ol>
</blockquote>
<p>蛋糕模式（cake pattern）是Scala实现依赖注入的方法之一，它利用Scala Mixin功能，让对象被创建时，才把相依的原件，透过Mixin的方式绑在一起。</p>
<h3 id="蛋糕模式的组成部分："><a href="#蛋糕模式的组成部分：" class="headerlink" title="蛋糕模式的组成部分："></a>蛋糕模式的组成部分：</h3><blockquote>
<ul>
<li>配置特质（Configuration Trait）：该结构定义了用于注入的对象的抽象<br>配置特质是对被依赖的组件提供层（the dependent component providers layers）的包装，它提供了根组件所依赖的行为和数据</li>
<li>具体的配置特质（Concrete Configuration Traits）：该结构定义了被依赖的结构具体是如何创建的，比如通过配置文件、数据库或者维护在内存的资源</li>
<li>内容特质（Context Trait）：该特质用于确定被载入的具体配置</li>
<li>依赖组件（Dependent Component）：该组件依赖于具体配置结构提供的对象</li>
</ul>
</blockquote>
<h3 id="蛋糕模式的实际问题："><a href="#蛋糕模式的实际问题：" class="headerlink" title="蛋糕模式的实际问题："></a>蛋糕模式的实际问题：</h3><blockquote>
<ul>
<li>将所依赖的对象配置给应用程序代码使得在运行时进行调整更换成为可能。这些配置信息由XML文件、数据库或者其他合适的文件提供</li>
<li>确定具体的配置可以在工厂对象中进行</li>
</ul>
</blockquote>
<h3 id="演示例子"><a href="#演示例子" class="headerlink" title="演示例子"></a>演示例子</h3><p>Config特质定义了load方法和text值，load方法在实例化时将被执行，用于载入配置信息。<br>一个具体的配置类型定义为InMemoryConfig，它定义了具体的Config行为。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Config</span> </span>&#123;</div><div class="line">  load</div><div class="line">  <span class="keyword">val</span> text: <span class="type">String</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">load</span></span>: <span class="type">Unit</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">InMemoryConfig</span> <span class="keyword">extends</span> <span class="title">Config</span> </span>&#123;</div><div class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> text = <span class="string">"Hello"</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">load</span> </span>= println(<span class="string">"load: "</span> + text)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Context特质用来表示蛋糕模式的内容对象，MyContext特质使用<code>this</code>子类型注解（self type annotation）指定Config类型将被混入到当前类或对象中，于是Config特质中的数据和方法就好像是定义在该特质中的一样。<br>注意，多个特质都可以被混入到this引用中，比如<code>this: ConfigContext with DAOContext with ConnectionManagerContext</code>。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Context</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyContext</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>: <span class="type">Config</span> =&gt;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">welcome</span> </span>= <span class="keyword">this</span>.text</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Env这个对象是单例模式在Scala中的语法化表示，它继承了混入InMemoryConfig特质的MyContext，它很好的表示了依赖嵌入环境。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Env</span> <span class="keyword">extends</span> <span class="title">MyContext</span> <span class="keyword">with</span> <span class="title">InMemoryConfig</span></span></div></pre></td></tr></table></figure></p>
<p>执行<code>println(Env.text)</code>将打印：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">load:</span> Hello</div><div class="line">Hello</div></pre></td></tr></table></figure></p>
<h3 id="蛋糕模式的优缺点"><a href="#蛋糕模式的优缺点" class="headerlink" title="蛋糕模式的优缺点"></a>蛋糕模式的优缺点</h3><blockquote>
<p><strong>优点</strong>：</p>
<ol>
<li>没有使用框架，仅使用语言特性</li>
<li>类型安全——缺失的依赖项在编译时被发现</li>
<li>功能强大——通过实现合适的依赖提供方法进行协助嵌入<br>缺点是代码模板复杂</li>
</ol>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.yunglinho.com/blog/2012/04/22/dependency-injection-in-scala/" target="_blank" rel="external">Dependency Injection in Scala</a></p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;依赖注入（Dependency-Injection）和控制反转（Inversion-of-Control）&quot;&gt;&lt;a href=&quot;#依赖注入（Dependency-Injection）和控制反转（Inversion-of-Control）&quot; class=&quot;heade
    
    </summary>
    
      <category term="Scala" scheme="http://blog.jasonding.top/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>【Scala】抽取器</title>
    <link href="http://blog.jasonding.top/2016/03/09/Scala/%E3%80%90Scala%E3%80%91%E6%8A%BD%E5%8F%96%E5%99%A8/"/>
    <id>http://blog.jasonding.top/2016/03/09/Scala/【Scala】抽取器/</id>
    <published>2016-03-09T03:13:06.000Z</published>
    <updated>2016-03-16T06:24:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>由于样本类和构造器模式相关联，所以在模式匹配中常使用样本类做数据的解构和分析。<br>有些情况下，或许希望能够在不创建关联的样本类的前提下编写出类似的模式匹配，此时抽取器（Extractor）可以用来定义与对象表达解耦的模式。</p>
<h2 id="抽取email地址的例子"><a href="#抽取email地址的例子" class="headerlink" title="抽取email地址的例子"></a>抽取email地址的例子</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>假设你需要分析一些代表email地址的字符串：对于给定的字符串，首先要判断它是否为email地址，如果是，再分析访问地址的用户名和域名。</p>
<blockquote>
<p>def isEmail(s: String): Boolean<br>def domain(s: String): String<br>def user(s: String): String</p>
</blockquote>
<p>这种方式有些笨拙，使用模式匹配的方式会有效解决这个问题。<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s <span class="keyword">match</span>&#123;</div><div class="line">    <span class="built_in">case</span> Email(user,domain) =&gt; println (user + <span class="string">" AT "</span> + domain)</div><div class="line">    <span class="built_in">case</span> <span class="keyword">_</span> =&gt; println (<span class="string">"not an email address"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但问题是String不是一个样本类，于是我们可以借助抽取器为内置的类型定义新的模式。</p>
<h3 id="抽取器基础"><a href="#抽取器基础" class="headerlink" title="抽取器基础"></a>抽取器基础</h3><p>Scala里的抽取器就是具有名为unapply成员方法的对象。<strong>unapply方法的目的是为了匹配并分解值，apply是其对偶方法，unapply逆转了apply的构建过程，将构建的对象进行分解。</strong></p>
<p>针对email的例子，可以使用如下方式进行编写程序：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">object EMail &#123;</div><div class="line">    def apply(user:<span class="built_in">String</span>,domain:<span class="built_in">String</span>) = user + <span class="string">"@"</span> + domain</div><div class="line">    def unapply(<span class="keyword">str</span>: <span class="built_in">String</span>) :<span class="built_in">Option</span>[(<span class="built_in">String</span>, <span class="built_in">String</span>)] =&#123;</div><div class="line">        val parts = <span class="keyword">str</span> split <span class="string">"@"</span></div><div class="line">        <span class="keyword">if</span>(parts.length==<span class="number">2</span>) <span class="literal">Some</span>(parts(<span class="number">0</span>),parts(<span class="number">1</span>)) <span class="keyword">else</span> <span class="literal">None</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用时是这样的：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scala&gt; EMail.unapply(<span class="string">"jasonding@gmail.com"</span>)</div><div class="line">res1: <span class="built_in">Option</span>[(<span class="built_in">String</span>, <span class="built_in">String</span>)] = <span class="literal">Some</span>((<span class="string">"jasonding"</span>, <span class="string">"gmail.com"</span>))</div><div class="line"></div><div class="line">scala&gt; EMail.unapply(<span class="string">"Jason Ding"</span>)</div><div class="line">res2: <span class="built_in">Option</span>[(<span class="built_in">String</span>, <span class="built_in">String</span>)] = <span class="literal">None</span></div></pre></td></tr></table></figure></p>
<p>在某种程度上来说，unapply和apply的作用相反，apply方法把两个字符串参数变成一个Email地址，而unapply方法反向变换，把一个字符串分解成两个部分：用户名和域名。unapply方法必须处理不能把一个字符串分解成两部分的情况，这也是为什么这里unapply方法返回Option类型的原因。</p>
<p><strong>apply方法被称为注入方法，因为它可以传入一些参数并生成指定子集的元素。unapply方法被称为抽取方法，因为它可以传入相同子集的元素并抽取其中的部分。注入方法和抽取方法常常处于同一个对象中，因为如此一来，你可以把对象名既当做构造器也当做模式用，这是对使用样本类作模式匹配的惯例的模仿。</strong></p>
<h3 id="无参数和带一个参数的模式定义"><a href="#无参数和带一个参数的模式定义" class="headerlink" title="无参数和带一个参数的模式定义"></a>无参数和带一个参数的模式定义</h3><p>上一小节例子中unapply方法在匹配成功时返回一个二元组。这可以很容易的推广到多于两个变量的情况。为了绑定N个变量，unapply方法可以返回一个<strong>N元组，封装在Some中</strong>。<br>对于一个只绑定一个变量的情况，为返回一个变量，该变量直接封装在Some中返回。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Twice</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(s:<span class="type">String</span>) = s + s</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(s:<span class="type">String</span>):<span class="type">Option</span>[<span class="type">String</span>] =&#123;</div><div class="line">        <span class="keyword">val</span> length=s.length/<span class="number">2</span></div><div class="line">        <span class="keyword">val</span> half = s.substring(<span class="number">0</span>,length)</div><div class="line">        <span class="keyword">if</span>(half == s.substring(length)) <span class="type">Some</span>(half) <span class="keyword">else</span> <span class="type">None</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个Extractor也可以绑定任何变量，这种情况下可以返回true和false代表匹配成功与否。比如下面的例子匹配一个字符串是否都是大写字母：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object UpperCase &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unapply</span><span class="params">(s:String)</span>:</span>Boolean = s.toUpperCase ==s</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后可以利用上面定义的Twice和UpperCase组合构造组合的模式定义：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def userTwiceUpper(s:String) = s <span class="keyword">match</span>&#123;</div><div class="line">    <span class="built_in">case</span> EMail(Twice(x @ UpperCase()),domain) =&gt;</div><div class="line">        <span class="string">"match:"</span> + x + <span class="string">" in domain "</span> + domain</div><div class="line">    <span class="built_in">case</span> <span class="keyword">_</span> =&gt; <span class="string">"no match"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用效果：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">scala</span>&gt; userTwiceUpper(<span class="string">"DIDI@hotmail.com"</span>)</div><div class="line">res1: String = match:<span class="keyword">DI</span> <span class="keyword">in</span> domain hotmail.com</div><div class="line"></div><div class="line"><span class="keyword">scala</span>&gt; userTwiceUpper(<span class="string">"DIDO@hotmail.com"</span>)</div><div class="line">res2: String = <span class="keyword">no</span> <span class="built_in">match</span></div><div class="line"></div><div class="line"><span class="keyword">scala</span>&gt; userTwiceUpper(<span class="string">"didi@hotmail.com"</span>)</div><div class="line">res3: String = <span class="keyword">no</span> <span class="built_in">match</span></div></pre></td></tr></table></figure></p>
<p>以<code>x @ UpperCase()</code>形式吧变量与UpperCase()模式进行变量绑定。</p>
<h3 id="变参抽取器"><a href="#变参抽取器" class="headerlink" title="变参抽取器"></a>变参抽取器</h3><p>针对这种变长类型的匹配，Scala定义了一个<code>unapplySeq</code>方法来支持这种用法，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">object Domain&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span><span class="params">(parts:String *)</span> :</span>String = parts.reverse.mkString(<span class="string">"."</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unapplySeq</span><span class="params">(whole:String)</span>:</span> Option[Seq[String]] =</div><div class="line">        Some(whole.split(<span class="string">"\\."</span>).reverse)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对象Domain定义unapplySeq方法，首先以“.”分割字符串，Split使用正规表达式，因此.需要使用\转义。unapplySeq结果返回一个封装在Some的Seq数据。</p>
<p>然后可以使用Domain抽取器来获取Email地址更详细的信息。比如查找用户名为“tom”，域名为某些含“com”的地址。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isTomDotCom</span><span class="params">(s:String)</span>:</span>Boolean =s match&#123;</div><div class="line">    case EMail(<span class="string">"tom"</span>,Domain(<span class="string">"com"</span>,_*)) =&gt; true</div><div class="line">    case _ =&gt; false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; isTomDotCom(<span class="string">"tom@sun.com"</span>)</div><div class="line">res0: <span class="keyword">Boolean</span> = <span class="keyword">true</span></div><div class="line"></div><div class="line">scala&gt; isTomDotCom(<span class="string">"peter@sun.com"</span>)</div><div class="line">res1: <span class="keyword">Boolean</span> = <span class="keyword">false</span></div><div class="line"></div><div class="line">scala&gt; isTomDotCom(<span class="string">"tom@acm.org"</span>)</div><div class="line">res2: <span class="keyword">Boolean</span> = <span class="keyword">false</span></div></pre></td></tr></table></figure></p>
<p>使用unapplySeq也支持返回一部分固定长度的变量加上后面变长的变量，这个返回值可以表示成一多元组，可变的部分放在最后。比如：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">object ExpendedEMail&#123;</div><div class="line">    def unapplySe<span class="string">q(email: String)</span></div><div class="line">        :Option[(String,Se<span class="string">q[String]</span>)] =&#123;</div><div class="line">        val parts = email <span class="keyword">split</span> <span class="string">"@"</span></div><div class="line">        if(parts.length==2)</div><div class="line">          Some(parts(0),parts(1).split("\\.<span class="string">").reverse)</span></div><div class="line">        else</div><div class="line">          None</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="中缀表达式中的抽取器"><a href="#中缀表达式中的抽取器" class="headerlink" title="中缀表达式中的抽取器"></a>中缀表达式中的抽取器</h2><p>解构列表、流的方法与创建它们的方法类似，都是使用 cons 操作符： :: 、 #:: ，比如：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val xs = <span class="number">58</span> #:: <span class="number">43</span> #:: <span class="number">93</span> #:: Stream.empty</div><div class="line">xs <span class="keyword">match</span> &#123;</div><div class="line">  <span class="built_in">case</span> <span class="built_in">first</span> #:: second #:: <span class="keyword">_</span> =&gt; <span class="built_in">first</span> - second</div><div class="line">  <span class="built_in">case</span> <span class="keyword">_</span> =&gt; <span class="number">-1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Scala允许以中缀方式来使用提取器。 所以，我们可以写成<code>e(p1, p2)</code>，也可以写成<code>p1 e p2</code>，其中e是抽取器，p1、p2是要提取的参数。<br>同样，中缀操作方式的<code>head #:: tail</code>可以被写成<code>#::(head, tail)</code>。一般来说，只有当一个抽取器看起来真的像操作符，才推荐以中缀操作方式来使用它。所以，列表和流的cons操作符一般使用中缀表达。</p>
<p>Scala的<code>#::</code>提取器代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">object <span class="comment">#:: &#123;</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span>[<span class="title">A</span>]<span class="params">(xs: Stream[A])</span>:</span> Option[(A, Stream[A]) =</div><div class="line">    <span class="keyword">if</span> (xs.isEmpty) <span class="keyword">None</span></div><div class="line">    <span class="keyword">else</span> Some((xs.head, xs.tail))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果给定的流是空的，抽取器就直接返回None。因此，case head #:: tail就不会匹配任何空的流。否则，就会返回一个Tuple2，其第一个元素是流的头，第二个元素是流的尾，尾本身又是一个流。这样，case head #:: tail就会匹配有一个或多个元素的流。如果只有一个元素，tail就会被绑定成空流。</p>
<h2 id="抽取器和样本类的对比"><a href="#抽取器和样本类的对比" class="headerlink" title="抽取器和样本类的对比"></a>抽取器和样本类的对比</h2><p>抽取器和样本类都可以用来做模式匹配，进行数据的结构和分析。但这两个概念有各自的特点。</p>
<h3 id="抽取器优于样本类的地方"><a href="#抽取器优于样本类的地方" class="headerlink" title="抽取器优于样本类的地方"></a>抽取器优于样本类的地方</h3><p>样本类的缺点是它暴露了数据的具体表达方式，如果匹配到样本类的构造器形式，就知道了选择器表达式实际上是特定样本类的实例。抽取器截断了数据表达与模式之间的联系，实现了<strong>表征独立</strong>（representation independence，让模式与被选择对象的数据类型之间毫无关系）<br>。在大型开发系统中，表征独立非常重要，因为这可以让修改部件的实现类型不会影响部件的使用者。<br>如果部件已经定义并导出了一套样本类的话，因为客户代码可能已经包含了对这些样本类的模式匹配，重命名某些样本类或修改类层级都将影响客户代码。但是，<strong>抽取器不会出现类似的问题，因为它们代表了数据表现和客户观察方式之间的间接适配层，你仍然可以修改类型的具体实现，只要对抽取器做更新即可</strong>。</p>
<h3 id="样本类优于抽取器的地方"><a href="#样本类优于抽取器的地方" class="headerlink" title="样本类优于抽取器的地方"></a>样本类优于抽取器的地方</h3><p>首先，样本类更易于建立和定义、需要更少的代码。<br>其次，它们通常能实现比抽取器更为高效的模式匹配，因为Scala编译器对于样本类模式的优化远胜于对抽取器模式的优化。这是由于样本类的机制是固定的，但抽取器的unapply和unapplySeq方法几乎能做任何事情。<br>第三，如果样本类继承自sealed基类，那么Scala编译器将采用穷举法检测模式匹配并在模式没有覆盖某种可能的组合值情况下报错，但对于抽取器来说不存在这种穷举检查。</p>
<h3 id="模式匹配采用哪种方法"><a href="#模式匹配采用哪种方法" class="headerlink" title="模式匹配采用哪种方法"></a>模式匹配采用哪种方法</h3><p>如果编写的代码是封闭的应用，那么样本类通常更为合适，因为它们更简洁，编写速度更快，而且有静态检查。<br>如果你决定之后要修改类层级，应用程序需要重构，并且如果你需要把类型暴露给未知的客户，那么抽取器更为合适，因为它们能保持表征独立。<br>实际上，可以始终以样本类开始，然后如果有新需求，将其改为抽取器。因为抽取器模式与样本类模式在Scala中看上去完全一致，所以你的客户代码中的模式匹配还将能够继续工作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Scala编程》</p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;由于样本类和构造器模式相关联，所以在模式匹配中常使用样本类做数据的解构和分析。&lt;br&gt;有些情况下，或许希望能够在不创建关联的样本类的前提下编
    
    </summary>
    
      <category term="Scala" scheme="http://blog.jasonding.top/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>【函数式】Monads模式初探——Option Monad</title>
    <link href="http://blog.jasonding.top/2016/03/05/Functional%20Programming/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91Monads%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94Option-Monad/"/>
    <id>http://blog.jasonding.top/2016/03/05/Functional Programming/【函数式】Monads模式初探——Option-Monad/</id>
    <published>2016-03-05T03:12:25.000Z</published>
    <updated>2016-03-16T06:24:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Option-Monad"><a href="#Option-Monad" class="headerlink" title="Option Monad"></a>Option Monad</h2><p>Scala中的Option是一个Monad实现。<br>Option的简化版定义如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Option</span>[+<span class="type">A</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>: <span class="type">A</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">Option</span>[<span class="type">B</span>] =</div><div class="line">    <span class="keyword">if</span>(isEmpty) <span class="type">None</span> <span class="keyword">else</span> <span class="type">Some</span>(f(<span class="keyword">this</span>.get))</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">Option</span>[<span class="type">B</span>]): <span class="type">Option</span>[<span class="type">B</span>] =</div><div class="line">    <span class="keyword">if</span>(isEmpty) <span class="type">None</span> <span class="keyword">else</span> f(<span class="keyword">this</span>.get)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Some</span>[+<span class="type">A</span>](<span class="params">x: <span class="type">A</span></span>) <span class="keyword">extends</span> <span class="title">Option</span>[<span class="type">A</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="literal">false</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span> </span>= x</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">None</span> <span class="keyword">extends</span> <span class="title">Option</span>[<span class="type">Nothing</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span> </span>= <span class="literal">true</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span> </span>= <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(<span class="string">"None.get"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码中，Option定义了flatMap，Some和None都被定义为case class，所以其名字就是构造器，无需定义unit函数。<br>Option可以看成是只有一个元素的容器：</p>
<blockquote>
<ul>
<li>map的工作就是对仅有的一个元素进行f调用，然后将结果打包成Option</li>
<li>flatMap的工作是对一个元素进行f调用，产生的结果已经是Option实例，并且没有其他的结果需要flatten</li>
</ul>
</blockquote>
<p>None的存在是唯一的插曲，map和flatMap对于None要做的额外工作就是检查自己是不是None，如果是，则直接返回None。因为None表示一个空的容器，因此不能进行其他的计算。</p>
<h2 id="用Monad规则验证Option"><a href="#用Monad规则验证Option" class="headerlink" title="用Monad规则验证Option"></a>用Monad规则验证Option</h2><p>对于Option，unit(x) == Some(x)。下面是Option的flatMap构造：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span>[<span class="title">U</span>]<span class="params">(f: T =&gt; Option[U])</span>:</span> Option[U] = this match &#123;</div><div class="line">  case Some(x) =&gt; f(x)</div><div class="line">  case <span class="keyword">None</span> =&gt; <span class="keyword">None</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们先证明<code>Some(x) flatMap f == f(x)</code>：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Some(x) flatMap f</div><div class="line"><span class="section">== Some(x) match &#123;</span></div><div class="line"><span class="code">    case Some(x) =&gt; f(x)</span></div><div class="line"><span class="code">    case None =&gt; None</span></div><div class="line"><span class="code">  &#125;</span></div><div class="line"><span class="section">== f(x)</span></div></pre></td></tr></table></figure></p>
<p>然后我们证明<code>opt flatMap Some == opt</code>：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">opt flatMap Some</div><div class="line"><span class="section">== opt match &#123;</span></div><div class="line"><span class="code">    case Some(x) =&gt; Some(x)</span></div><div class="line"><span class="code">    case None =&gt; None</span></div><div class="line"><span class="code">  &#125;</span></div><div class="line"><span class="section">== opt</span></div></pre></td></tr></table></figure></p>
<p>这里，我们看到对一个Option对象opt进行flatMap操作，<br>其中映射函数式Some构造函数时，返回的是初始时的opt</p>
<p>我们还要证明<code>opt flatMap f flatMap g == opt flatMap (x =&gt; f(x) flatMap g)</code>：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">opt flatMap f flatMap g</div><div class="line"><span class="section">== opt match &#123; case Some(x) =&gt; f(x) case None =&gt; None&#125;</span></div><div class="line"><span class="code">       match &#123; case Some(y) =&gt; g(y) case None =&gt; None&#125;</span></div><div class="line"><span class="comment">//如果将第二个match表达式嵌入第一个match表达式中，将得到</span></div><div class="line"><span class="section">== opt match &#123;</span></div><div class="line"><span class="code">    case Some(x) =&gt;</span></div><div class="line"><span class="code">      f(x) match &#123;case Some(y) =&gt; g(y) case None =&gt; None&#125;</span></div><div class="line"><span class="code">    case None =&gt;</span></div><div class="line"><span class="code">      None match &#123;case Some(y) =&gt; g(y) case None =&gt; None&#125;</span></div><div class="line"><span class="code">  &#125;</span></div><div class="line"><span class="section">== opt match &#123;</span></div><div class="line"><span class="code">    case Some(x) =&gt;</span></div><div class="line"><span class="code">      f(x) match &#123;case Some(y) =&gt; g(y) case None =&gt; None&#125;</span></div><div class="line"><span class="code">    case None =&gt; None</span></div><div class="line"><span class="code">  &#125;</span></div><div class="line"><span class="section">== opt match &#123;</span></div><div class="line"><span class="code">    case Some(x) =&gt; f(x) flatMap g</span></div><div class="line"><span class="code">    case None =&gt; None</span></div><div class="line"><span class="code">  &#125;</span></div><div class="line"><span class="section">== opt flatMap (x =&gt; f(x) flatMap g)</span></div></pre></td></tr></table></figure></p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Option-Monad&quot;&gt;&lt;a href=&quot;#Option-Monad&quot; class=&quot;headerlink&quot; title=&quot;Option Monad&quot;&gt;&lt;/a&gt;Option Monad&lt;/h2&gt;&lt;p&gt;Scala中的Option是一个Monad实现。&lt;br&gt;Op
    
    </summary>
    
      <category term="Functional Programming" scheme="http://blog.jasonding.top/categories/Functional-Programming/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
      <category term="Functional Programming" scheme="http://blog.jasonding.top/tags/Functional-Programming/"/>
    
  </entry>
  
  <entry>
    <title>【函数式】Monads模式初探——for解析式</title>
    <link href="http://blog.jasonding.top/2016/03/05/Functional%20Programming/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91Monads%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94for%E8%A7%A3%E6%9E%90%E5%BC%8F/"/>
    <id>http://blog.jasonding.top/2016/03/05/Functional Programming/【函数式】Monads模式初探——for解析式/</id>
    <published>2016-03-05T02:50:06.000Z</published>
    <updated>2016-03-16T06:24:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="for表达式是monad语法糖"><a href="#for表达式是monad语法糖" class="headerlink" title="for表达式是monad语法糖"></a>for表达式是monad语法糖</h2><p>先看一组示例：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">case class Person(<span class="name">name</span>: String, isMale: Boolean, children: Person*)</div><div class="line"></div><div class="line">val lara = Person(<span class="string">"Lara"</span>, false)</div><div class="line">val bob = Person(<span class="string">"Bob"</span>, true)</div><div class="line">val julie = Person(<span class="string">"Julie"</span>, false, lara, bob)</div><div class="line">val persons = List(<span class="name">lara</span>, bob, julie)</div><div class="line"></div><div class="line">println(</div><div class="line">  <span class="name">persons</span> filter (<span class="name">p</span> =&gt; !p.isMale) flatMap (<span class="name">p</span> =&gt;</div><div class="line">    (<span class="name">p</span>.children map (<span class="name">c</span> =&gt; (<span class="name">p</span>.name, c.name))))</div><div class="line">)</div><div class="line"></div><div class="line">println(</div><div class="line">  <span class="name">for</span> (<span class="name">p</span> &lt;- persons<span class="comment">; if !p.isMale; c &lt;- p.children)</span></div><div class="line">    yield (<span class="name">p</span>.name, c.name)</div><div class="line">)</div><div class="line">// output is</div><div class="line">// List((<span class="name">Julie</span>,Lara), (<span class="name">Julie</span>,Bob))</div></pre></td></tr></table></figure></p>
<p>Person类包含了人员名称，是否是男性，以及他的孩子的字段。代码的意义是找出列表中所有的妈妈和孩子结对的名称。<br>分别使用了map、flatMap、filter的方式进行查询，还使用了for表达式完成，得到相同的结果。</p>
<p>实际上，<strong>Scala编译器能够把所有使用yield产生结果的for表达式转移为高阶方法map、flatMap及filter的组合调用</strong>。所有的不带yield的for循环都会被转移为仅对filter和foreach的调用。</p>
<h2 id="for表达式说明"><a href="#for表达式说明" class="headerlink" title="for表达式说明"></a>for表达式说明</h2><p>for表达式形式如下：<br><code>for (seq) yield expr</code><br>这里，seq由生成器、定义及过滤器组成序列，以分号隔开。如果在for表达式中用花括号代替小括号包围表达式序列，那么分号是可选的。<br>比如下面的示例：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">for</span> (p &lt;- persons; n = p.name; <span class="built_in">if</span> (n startsWith <span class="string">"To"</span>))</div><div class="line">  <span class="built_in">yield</span> n</div><div class="line"></div><div class="line"><span class="built_in">for</span> &#123;</div><div class="line">  p &lt;- persons            <span class="comment">//生成器</span></div><div class="line">  n = p.name              <span class="comment">//定义</span></div><div class="line">  <span class="built_in">if</span> (n startsWith <span class="string">"To"</span>)  <span class="comment">//过滤器</span></div><div class="line">&#125; <span class="built_in">yield</span> n</div></pre></td></tr></table></figure></p>
<p>生成器的形式为<code>patten &lt;- expression</code>，表达式expression典型的返回值是列表，不过它可以泛化。模式pattern一一匹配列表里的所有元素。如果匹配成功，模式中的变量将绑定元素的相应成分。但即使匹配失败也不会抛出MatchError，而只是在迭代中丢弃这个元素罢了。<br>所有的for表达式都以生成器开始。如果for表达式中有若干生成器，那么后面的生成器比前面的变化的更快。</p>
<h2 id="for表达式的转译"><a href="#for表达式的转译" class="headerlink" title="for表达式的转译"></a>for表达式的转译</h2><p>对于每一个Monad来说，都支持for表达式，而每个for表达式都可以用三个高阶函数map、flatMap及filter表达。</p>
<h3 id="基本的转译方式"><a href="#基本的转译方式" class="headerlink" title="基本的转译方式"></a>基本的转译方式</h3><blockquote>
<ul>
<li><strong>带一个生成器的for表达式</strong><br><code>for (x &lt;- expr1) yield expr2</code>转译为<code>expr1.map(x =&gt; expr2)</code></li>
<li><strong>以生成器和过滤器开始的for表达式</strong><br><code>for (x &lt;- expr1 if expr2) yield expr3</code><br>第一个表达式可以转译成<code>for (x &lt;- expr1 filter (x =&gt; expr2)) yield expr3</code></li>
<li><strong>以两个生成器开始的for表达式</strong><br><code>for (x &lt;- expr1; y &lt;- expr2; seq) yield expr3</code><br>假设seq是任意序列的生成器、定义及过滤器，也可能为空。两个生成器被转译为flatMap的应用：<br><code>expr1.flatMap(x =&gt; for (y &lt;- expr2; seq) yield expr3 )</code><br>这就生成了另一个传递给flatMap的函数值形式的for表达式。</li>
</ul>
</blockquote>
<p>再举个例子：<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 第一步转译</div><div class="line">for (n &lt;- ns;</div><div class="line">    o &lt;- os;</div><div class="line">    p &lt;- ps)</div><div class="line">    yield n*o*p</div><div class="line">// 第二步转译</div><div class="line">ns <span class="keyword">flatMap</span> &#123;<span class="attr">n</span> =&gt;</div><div class="line">          for(o &lt;- os;</div><div class="line">          p &lt;- <span class="built_in">ps</span>)</div><div class="line">          yield n*o*p&#125;</div><div class="line">// 第三步转译</div><div class="line">ns <span class="keyword">flatMap</span> &#123; <span class="attr">n</span> =&gt;</div><div class="line">          os flatMap &#123; <span class="attr">o</span> =&gt;</div><div class="line">          for(p &lt;- <span class="built_in">ps</span>)</div><div class="line">          yield n*o*p&#125;&#125;</div><div class="line">// 第四步转译</div><div class="line">ns <span class="keyword">flatMap</span> &#123;<span class="attr">n</span> =&gt;</div><div class="line">          os flatMap &#123;<span class="attr">o</span> =&gt;</div><div class="line">          &#123;<span class="built_in">ps</span> map &#123;<span class="attr">p</span> =&gt; n*o*p&#125;&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="转译for循环"><a href="#转译for循环" class="headerlink" title="转译for循环"></a>转译for循环</h3><p>for表达式也有一个命令式(imperative)的版本，用于那些你只调用一个函数，不返回任何值而仅仅执行了副作用，这个版本去掉了yield声明。<br>for循环的转译版本只需用到foreach，<code>for (x &lt;- expr1) body</code>，转译为<code>expr1 foreach (x =&gt; body)</code>。<br>更大的例子是，<code>for (x &lt;- expr1; if expr2; y &lt;- expr3) body</code>。它将被转译为：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">expr1 filter (<span class="name">x</span> =&gt; expr2) foreach (<span class="name">x</span> =&gt;</div><div class="line">  expr3 foreach (<span class="name">y</span> =&gt; body))</div></pre></td></tr></table></figure></p>
<p>foreach依然可以使用map来实现：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class M[A] &#123;</div><div class="line">  def map[<span class="string">B</span>](<span class="link">f: A =&gt; B</span>): M[B] = ...</div><div class="line">  def flatMap[<span class="string">B</span>](<span class="link">f: A =&gt; M[B]</span>): M[B] = ...</div><div class="line">  def foreach[<span class="string">B</span>](<span class="link">f: A =&gt; B</span>): Unit = &#123;</div><div class="line"><span class="code">    map(f)</span></div><div class="line"><span class="code">    ()</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>foreach可以通过调用map并丢掉结果来实现。不过这么做运行效率不高，所以scala允许你用自己的方式定义foreach。</p>
<h3 id="转译定义"><a href="#转译定义" class="headerlink" title="转译定义"></a>转译定义</h3><p>如果for表达式中内嵌定义，如<code>for (x &lt;- expr1; y = expr2; seq) yield expr3</code>。<br>那么将转译为<code>for ((x, y) &lt;- for (x &lt;- expr1) yield (x, expr2); seq) yield expr3</code>。<br>这里每次产生新的x值的时候，expr2都被重新计算。所以这可能会浪费计算资源，造成重复计算。<br>比如下面的例子和更好的写法：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- <span class="number">1</span> <span class="keyword">to</span> <span class="number">100</span>; y = expensiveComputationNotInvolvingX)</div><div class="line"><span class="keyword">yield</span> x*y</div><div class="line"></div><div class="line"><span class="comment">// better code</span></div><div class="line"><span class="keyword">val</span> y = expensiveComputationNotInvolvingX</div><div class="line"><span class="keyword">for</span> (x &lt;- <span class="number">1</span> <span class="keyword">to</span> <span class="number">1000</span>) <span class="keyword">yield</span> x*y</div></pre></td></tr></table></figure></p>
<h3 id="生成器中的模式"><a href="#生成器中的模式" class="headerlink" title="生成器中的模式"></a>生成器中的模式</h3><p>如果生成器的左侧是模式pat而不是简单变量，那么转译方法将变得复杂很多。<br><strong>绑定变量元组</strong><br><code>for ((x1, ..., xn) &lt;- expr1) yield expr2</code><br>转译为：<br><code>expr1.map {case (x1, ..., xn) =&gt; expr2}</code></p>
<p><strong>任意模式</strong><br><code>for (pat &lt;- expr1) yield expr2</code><br>转译为：<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">expr1 <span class="keyword">filter</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="attr">pat</span> =&gt; <span class="keyword">true</span></div><div class="line">  <span class="keyword">case</span> _ =&gt; <span class="keyword">false</span></div><div class="line">&#125; <span class="keyword">map</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="attr">pat</span> =&gt; expr2</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即，生成的条目首先经过过滤并且仅有那些匹配与pat的才会被映射。因此，这保证了模式匹配生成器不会抛出MatchError。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>因为for表达式的转译仅依赖于map、flatMap和filter的搭配，所以可以吧for表达式应用于大批数据类型（这些数据类型可以用Monad来描述和概括）上。<br>除了列表、数组之外，Scala标准库中还有许多其他类型支持四种方法（map、flatMap、filter、foreach），从而允许for表达式存在。同样，如果你自己的数据类型定义了需要的方法也可以完美支持for表达式。如果只定义map、flatMap、filter、foreach这些方法的子集，从而部分支持for表达式或循环。<br>规则如下：</p>
<blockquote>
<ul>
<li>如果定义了map，可以允许单一生成器组成的for表达式</li>
<li>如果定义了flatMap和map，可以允许若干个生成器组成的for表达式</li>
<li>如果定义了foreach，允许for循环</li>
<li>如果定义了filter，for表达式中允许以if开头的过滤器表达式</li>
</ul>
</blockquote>
<p>for表达式的转译发生在类型检查之前。这可以保持最大的灵活性，因为接下来只需for表达式展开的结果通过类型检查即可。</p>
<p>在函数式编程中，Monad定制了map、flatMap和filter功能，它可以解释多种类型的计算，包括从集合、状态和I/O操纵的计算、回溯计算以及交易等，不一而足。</p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;for表达式是monad语法糖&quot;&gt;&lt;a href=&quot;#for表达式是monad语法糖&quot; class=&quot;headerlink&quot; title=&quot;for表达式是monad语法糖&quot;&gt;&lt;/a&gt;for表达式是monad语法糖&lt;/h2&gt;&lt;p&gt;先看一组示例：&lt;br&gt;&lt;figure
    
    </summary>
    
      <category term="Functional" scheme="http://blog.jasonding.top/categories/Functional/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
      <category term="Functional Programming" scheme="http://blog.jasonding.top/tags/Functional-Programming/"/>
    
  </entry>
  
  <entry>
    <title>【函数式】Monads模式初探——Monad概念</title>
    <link href="http://blog.jasonding.top/2016/03/01/Functional%20Programming/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91Monads%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94Monad%E6%A6%82%E5%BF%B5/"/>
    <id>http://blog.jasonding.top/2016/03/01/Functional Programming/【函数式】Monads模式初探——Monad概念/</id>
    <published>2016-03-01T02:12:21.000Z</published>
    <updated>2016-03-17T02:36:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单子"><a href="#单子" class="headerlink" title="单子"></a>单子</h2><p>单子（Monad）是一种将函子组合应用的方法。在计算机科学里，单子经常用来代表计算（computation）。单子能用来把与业务无关的通用程序行为抽象出来，比如有用来处理并行（Future）、异常（Option和Try等）、甚至副作用的单子。<br>单子的flatMap和unit操作作为构建数据类型的基本操作，可以实现很多复杂的高阶函数。</p>
<h2 id="单子的程序描述"><a href="#单子的程序描述" class="headerlink" title="单子的程序描述"></a>单子的程序描述</h2><p>Monad定义了unit和flatMap两个函数。Monad都是Functor，因为我们可以用flatMap+unit来实现map。我们可以定义Monad继承自Functor特质。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">trait Functor[F[_]] &#123;</div><div class="line">  def map[<span class="string">A, B</span>](<span class="link">fa: F[A]</span>)(f: A =&gt; B): F[B]</div><div class="line">&#125;</div><div class="line"></div><div class="line">trait Monad[M[_]] extends Functor[M] &#123;</div><div class="line">  def unit[<span class="string">A</span>](<span class="link">a: A</span>): M[A]</div><div class="line">  def flatMap[<span class="string">A, B</span>](<span class="link">ma: M[A]</span>)(f: A =&gt; M[B]): M[B]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>unit可以看成是Monad的构造函数或者工厂函数，它用来创建一个Monad实例。unit表示“装箱”。</li>
<li>flatMap和map函数类似，不同的是它接受的参数f返回的是M[B]。flatMap会对Monad里的每一个元素都产生一个新的Monad容器，然后所有这些容器里的元素会被取出，而组合到一个Monad容器里。</li>
<li>unit,map,flatMap是Monad的三个必要函数，其中map可以由unit和flatMap来实现<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def map[<span class="string">A, B</span>](<span class="link">f: A =&gt; B</span>): M[B] =</div><div class="line">  flatMap(a =&gt; unit(f(a)))</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="Monad类代码"><a href="#Monad类代码" class="headerlink" title="Monad类代码"></a>Monad类代码</h3><p>上面是定义了Monad特质，定义了Monad需要实现的unit和flatMap接口，而实际的monad是指<code>M[_]</code>这个类型构造器。<br>而下面的M则是指一个Monad类：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class M[A] &#123;</div><div class="line">  def flatMap[<span class="string">B</span>](<span class="link">f: A =&gt; M[B]</span>): M[B] = ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">def unit[<span class="string">A</span>](<span class="link">x: A</span>): M[A] = ...</div></pre></td></tr></table></figure></p>
<h3 id="其他风格的Monad代码"><a href="#其他风格的Monad代码" class="headerlink" title="其他风格的Monad代码"></a>其他风格的Monad代码</h3><p>有的Monad风格是这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">trait Monad[M[_]] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span>[<span class="title">A</span>]<span class="params">(a: A)</span>:</span> M[A]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>[<span class="title">A</span>]<span class="params">(mma: M[M[A]])</span>:</span> M[A]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的flatten也叫join或者bind，它接受一个包裹两层的类型，转换成包裹一层的类型。<br>其实flatten可以通过flatMap推导出来，<code>def flatten[A](mma: M[M[A]]): M[A] = flatMap(mma)(ma =&gt; ma)</code>，所以这个定义和之前的Monad特质的定义时等价的。</p>
<h2 id="单子法则"><a href="#单子法则" class="headerlink" title="单子法则"></a>单子法则</h2><h3 id="结合性法则-associative-law"><a href="#结合性法则-associative-law" class="headerlink" title="结合性法则(associative law)"></a>结合性法则(associative law)</h3><p>flatMap满足结合性法则<br><code>m flatMap f flatMap g == m flatMap (x =&gt; f(x) flatMap g)</code></p>
<h3 id="Kleisli组合法则-kleisli-composition"><a href="#Kleisli组合法则-kleisli-composition" class="headerlink" title="Kleisli组合法则(kleisli composition)"></a>Kleisli组合法则(kleisli composition)</h3><p>Monoid的结合性操作<code>op(a, op(b, c)) == op(op(a, b), c)</code>，这对于Monad来说，用flatMap难以表达该操作。<br>如果不对Monadic值M[A]进行结合性操作，而是对Monadic函数A =&gt; M[B]证明结合性操作就会相对容易。<br><code>A =&gt; M[B]</code>是瑞士数学家Heinrich Kleisli法则的箭头（Kleisli Arrow）。我们可以用Kleisli Arrow来实现一个函数compose：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def compose[<span class="string">A, B, C</span>](<span class="link">f: A =&gt; M[B], g: B =&gt; M[C]</span>): A =&gt; M[C] =</div><div class="line">  a =&gt; flatMap(f(a))(g)</div></pre></td></tr></table></figure></p>
<p>compose函数满足<code>compose(f,compose(g,h)) == compose(compose(f,g),h)</code>。</p>
<h3 id="恒等法则-identity-law"><a href="#恒等法则-identity-law" class="headerlink" title="恒等法则(identity law)"></a>恒等法则(identity law)</h3><p>在Monoid中，identity相对于op操作的作用，在Monad中，unit操作是compose函数的元函数。<br>通过unit我们可以证明Monad的左右恒等：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">compose</span><span class="params">(f,unit)</span></span> == f</div><div class="line"><span class="function"><span class="title">compose</span><span class="params">(unit,f)</span></span> == f</div></pre></td></tr></table></figure></p>
<p>unit操作还满足下面两个等式：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unit(<span class="name">x</span>) flatMap f == f(<span class="name">x</span>)</div><div class="line">m flatMap unit == m</div></pre></td></tr></table></figure></p>
<h2 id="单子的形象解释"><a href="#单子的形象解释" class="headerlink" title="单子的形象解释"></a>单子的形象解释</h2><p>如果说functor是应用一个函数到包裹的值，那么monad则是<strong>应用一个返回包裹值的函数到一个包裹的值</strong>。<br><img src="http://adit.io/imgs/functors/bind_def.png" alt=""><br>上图表示，首先获得一个Monad，其次定义一个返回Monad的函数如half，最后结果也会返回一个Monad。<br>这里half函数是输入一个值然后返回一个包裹的值，如果输入的是一个包裹的值，那么代码就不工作了。如下面两幅图所示：<br><img src="http://adit.io/imgs/functors/half.png" alt=""><br><img src="http://adit.io/imgs/functors/half_ouch.png" alt=""></p>
<p>Monad在输入一个包裹值到一个函数的过程中要做到的是：</p>
<blockquote>
<ol>
<li>绑定已经解除包裹的值</li>
<li>将已经解除包裹的值输入函数</li>
<li>一个被重新包裹的值被输出</li>
</ol>
</blockquote>
<p><img src="http://adit.io/imgs/functors/monad_just.png" alt=""></p>
<p>那么，对一个包裹的值应用多次half函数将是这样的：</p>
<p><img src="http://adit.io/imgs/functors/monad_chain.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Monoid是元素对象的组合的范畴，如果这种元素对象是函数或函子，那么Monad是自函子的组合范畴，Monad也是一种特殊的Monoid子集。<br>所以正应了那句名言“单子说白了不过就是自函子范畴上的一个幺半群而已（A monad is just a monoid in the category of endofunctors）”。</p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单子&quot;&gt;&lt;a href=&quot;#单子&quot; class=&quot;headerlink&quot; title=&quot;单子&quot;&gt;&lt;/a&gt;单子&lt;/h2&gt;&lt;p&gt;单子（Monad）是一种将函子组合应用的方法。在计算机科学里，单子经常用来代表计算（computation）。单子能用来把与业务无关的通用程
    
    </summary>
    
      <category term="Functional Programming" scheme="http://blog.jasonding.top/categories/Functional-Programming/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
      <category term="Functional Programming" scheme="http://blog.jasonding.top/tags/Functional-Programming/"/>
    
  </entry>
  
  <entry>
    <title>【函数式】Monads模式初探——Endofunctor</title>
    <link href="http://blog.jasonding.top/2016/02/23/Functional%20Programming/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91Monads%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94Endofunctor/"/>
    <id>http://blog.jasonding.top/2016/02/23/Functional Programming/【函数式】Monads模式初探——Endofunctor/</id>
    <published>2016-02-23T03:37:42.000Z</published>
    <updated>2016-03-16T06:24:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自函子"><a href="#自函子" class="headerlink" title="自函子"></a>自函子</h2><p>自函子（Endofunctor）是一个将范畴映射到自身的函子（A functor that maps a category to itself）。函子是将一个范畴转换到另一个范畴，所以自函子是一种特殊的函子。<br>由三部分组成：</p>
<blockquote>
<ol>
<li>一组元素对象</li>
<li>一组态射</li>
<li>态射组合（二元运算）</li>
</ol>
</blockquote>
<p>如果这个范畴满足结合律，那么它是一个半群；如果半群满足幺元（单位元，identity），那么它是幺半群（Monoid）。<br>因此，函子是将一个Monoid中的元素对象映射到另外一个Monoid的元素对象，态射也是这么映射的。而自函子映射的这两个Monoid是同一个。<br>假设这个自函子为F，则对于F[Int]作用的结果仍是Int，对于函数f: Int=&gt;String映射的结果F[f]也仍是函数f，所以自函子对范畴中的元素和关系不做任何改变。</p>
<h2 id="Hask范畴"><a href="#Hask范畴" class="headerlink" title="Hask范畴"></a>Hask范畴</h2><p>Haskell里的所有类型和函数都放到一个范畴里，取名为Hask。<br><img src="http://hongjiang.info/wp-content/uploads/2013/12/hask-cat.jpg" alt=""><br>解释上图，A,B代表普通类型如String,Int,Boolean等，这些(有限的)普通类型是一组类型集合，还有一组类型集合是衍生类型(即由类型构造器与类型参数组成的)，这是一个无限集合(可以无限衍生下去)。这样范畴Hask就涵盖了haskell中所有的类型。</p>
<p>对于范畴Hask来说，如果有一个函子F，对里面的元素映射后，其结果仍属于Hask，比如我们用List这个函子：</p>
<blockquote>
<p>List[A], List[List[A]], List[List[List[A]]]…</p>
</blockquote>
<p>发现这些映射的结果也是属于Hask范畴(子集)，所以这是一个自函子，实际上在Hask范畴上的所有函子都是自函子。</p>
<h2 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h2><p>Hask范畴结构是一个分形（fractal）结构。<br><img src="http://hongjiang.info/wp-content/uploads/2013/12/fern.jpg" alt=""><br>如上面的这片叶子，它的每一簇分支，形状上与整体的形状是完全一样的，即局部与整体是一致的结构，并且局部可以再分解下去。</p>
<p><strong>这种结构在函数式语言里也是很常用的，最典型的如List结构，由head和tail两部分组合而成，而每个tail也是一个List结构，可以递归的分解下去。</strong></p>
<h2 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h2><p>由于关于自函子的中文介绍比较少，所以这篇文章我基本都是引用hongjiang的<a href="http://hongjiang.info/understand-monad-5-what-is-endofunctor/" target="_blank" rel="external">自函子(Endofunctor)是什么</a>。<br>希望加深理解之后，再填充更多原创内容。</p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自函子&quot;&gt;&lt;a href=&quot;#自函子&quot; class=&quot;headerlink&quot; title=&quot;自函子&quot;&gt;&lt;/a&gt;自函子&lt;/h2&gt;&lt;p&gt;自函子（Endofunctor）是一个将范畴映射到自身的函子（A functor that maps a category to i
    
    </summary>
    
      <category term="Functional Programming" scheme="http://blog.jasonding.top/categories/Functional-Programming/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
      <category term="Functional Programming" scheme="http://blog.jasonding.top/tags/Functional-Programming/"/>
    
  </entry>
  
  <entry>
    <title>【函数式】Monads模式初探——Functor</title>
    <link href="http://blog.jasonding.top/2016/02/23/Functional%20Programming/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91Monads%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94Functor/"/>
    <id>http://blog.jasonding.top/2016/02/23/Functional Programming/【函数式】Monads模式初探——Functor/</id>
    <published>2016-02-23T03:36:14.000Z</published>
    <updated>2016-03-16T06:24:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函子与范畴"><a href="#函子与范畴" class="headerlink" title="函子与范畴"></a>函子与范畴</h2><p>函子（functor）是<strong>从一个范畴到另一个范畴的转换</strong>，并且其亦可转换/保持态射（morphism）。<br>一个<strong>态射</strong>是从一个范畴里的一个值到同一个范畴里的另一个值的变换。在猫的范畴的例子里，一个态射好比一个盒子，能够把黯淡无光的猫转化为一个霓虹闪耀的猫。在类型的范畴里（计算机科学常用的范畴），一个态射是一个把某类型转化为另一个类型的函数。<br>函子是可以把猫转化为狗的东西（不同范畴的转换）。函子可以把暗淡的猫转换成暗淡的狗，光彩的猫转换成光彩的狗。函子还可以连态射都转换过去，这样可以把暗淡的狗转化为光彩的狗。</p>
<p><img src="http://7nj1qk.com1.z0.glb.clouddn.com/%40%2Fscala%2Ffunctional%2Ffunctor_transform.jpg" alt=""><br>图中，下面的圈子表示所有的类型组成的范畴。里面包括标准的String、Double和其他Scala能定义的类型。函子F是Scala里的一个类型构造器。对于一个范畴中的任意类型T，可以把该类型置于类型构造器<code>F[_]</code>中，从而得到一个新类型<code>F[T]</code>。</p>
<h2 id="对函子的描述"><a href="#对函子的描述" class="headerlink" title="对函子的描述"></a>对函子的描述</h2><p>函子本质上是范畴之间的转换。<br><img src="http://7nj1qk.com1.z0.glb.clouddn.com/%40%2Fscala%2Ffunctional%2Ffunctor.png" alt=""><br>上图表示范畴C到范畴D的函子。图中，对象A和B被转换到了范畴D中同一个对象，因此，态射g就被转换成了一个源对象和目标对象相同的态射（不一定是单位态射），而且id_A和id_B变成了相同的态射。对象之间的转换是用浅黄色的虚线箭头表示，态射之间的转换是用蓝紫色的箭头表示。</p>
<p>范畴之间的转换必须在转换时保留所有的态射才能称为函子转换。也就是说，如果在第一个范畴有个操作类型的函数，那么我们也应该有个转换后的函数能够操作转换后的类型。比如说，如果我们有个吧String转换为Int的函数，那么我们也应该能够把F[String]转换成F[Int]，这正是map方法所提供的功能。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">trait Functor[F[_]] &#123;</div><div class="line">  def apply[<span class="string">A</span>](<span class="link">x: A</span>): F[A]</div><div class="line">  def map[<span class="string">A, B</span>](<span class="link">x: F[A]</span>)(f: A =&gt; B): F[B]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>apply方法的作用——对于任意类型A，一个函子能够在新范畴里构造一个类型F[A]。<br>map方法的作用——给定一个转换后的类型F[A]和一个在原范畴里的态射A =&gt; B，能够创建一个F[B]类型的结果。也就是说，我们有个新函数能够接受F[A]，返回F[B]。</p>
<p>简单的说，函子是实现了map方法的数据类型。<br>举例来说，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Functor</span>[<span class="type">F</span>[_]] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](x: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListFunctor</span> <span class="keyword">extends</span> <span class="title">Functor</span>[<span class="type">List</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](list: <span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">List</span>[<span class="type">B</span>] = list map f</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> l1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> result = <span class="type">ListFunctor</span>.fmap(l1)(i =&gt; i+<span class="number">1</span>)</div><div class="line">println(result)</div><div class="line"><span class="comment">// print is</span></div><div class="line"><span class="comment">// List(2, 3, 4)</span></div></pre></td></tr></table></figure></p>
<h2 id="函子的形象演示"><a href="#函子的形象演示" class="headerlink" title="函子的形象演示"></a>函子的形象演示</h2><p>假设有一个容器（container），这里的容器可以认为是一种上下文（context）或者是为函数提供的计算上下文（computational context）。<br>在图中表示为一个盒子。当一个元素被上下文包裹，我们不能简单的对该元素应用一般的运算方法，于是需要使用map函数（Haskell中称为fmap）。<br><img src="http://adit.io/imgs/functors/no_fmap_ouch.png" alt=""><br>map函数知道如何将普通函数应用到一个被上下文包裹的元素上。<br><img src="http://adit.io/imgs/functors/fmap_apply.png" alt=""></p>
<p>函子（functor）是定义了如何应用map的类型类（typeclass）。<br><img src="http://adit.io/imgs/functors/functor_def.png" alt=""><br>如果我们要将普通函数应用到一个有盒子上下文包裹的值，那么我们首先需要定义一个叫Functor的数据类型，在这个数据类型中需要定义如何使用map或fmap来应用这个普通函数。<br><img src="http://adit.io/imgs/functors/fmap_def.png" alt=""></p>
<p>函子内部工作原理可以认为是这样的：</p>
<blockquote>
<ol>
<li>将值从上下文盒子中解救出来</li>
<li>将外部指定的函数(+3)应用到这个值上，得到一个新的值(5)</li>
<li>再将这个新值放入到上下文盒子中</li>
</ol>
</blockquote>
<p><img src="http://adit.io/imgs/functors/fmap_just.png" alt=""><br>下图显示了如何将一个普通函数应用到值集合，不是单个值，而是值的集合数组中，图中数组函子将数组一个个打开（遍历），然后分别将普通函数应用到这些元素中，最后返回一个新的集合值。<br><img src="http://adit.io/imgs/functors/fmap_list.png" alt=""></p>
<h2 id="补充：高阶类型"><a href="#补充：高阶类型" class="headerlink" title="补充：高阶类型"></a>补充：高阶类型</h2><p>基本泛型：<br><img src="http://hongjiang.info/wp-content/uploads/2013/07/hk-1.png" alt=""><br>如果类型参数也是一个泛型（类型构造器）：<br><img src="http://hongjiang.info/wp-content/uploads/2013/07/hk-2.png" alt=""><br>对类型的归纳：<br><img src="http://hongjiang.info/wp-content/uploads/2013/07/hk-41.png" alt=""></p>
<p>类型（type）是对数据的抽象，而高阶类型（higher-kinded type）是对类型的抽象：<br><img src="http://hongjiang.info/wp-content/uploads/2013/07/hk-6.png" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.jdon.com/idea/functor-monad.html" target="_blank" rel="external">函数编程中functor和monad的形象解释</a><br><a href="http://www.amazon.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Scala-%E8%8B%8F%E7%91%9E%E8%8C%A8/dp/B00RS6C9F8/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1456194016&amp;sr=1-2" target="_blank" rel="external">深入理解Scala</a><br><a href="http://hongjiang.info/scala-higher-kinded-type/" target="_blank" rel="external">理解高阶类型</a><br><a href="http://www.jianshu.com/p/31377066bf97" target="_blank" rel="external">Scala和范畴论 – 对Monad的一点认识</a></p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函子与范畴&quot;&gt;&lt;a href=&quot;#函子与范畴&quot; class=&quot;headerlink&quot; title=&quot;函子与范畴&quot;&gt;&lt;/a&gt;函子与范畴&lt;/h2&gt;&lt;p&gt;函子（functor）是&lt;strong&gt;从一个范畴到另一个范畴的转换&lt;/strong&gt;，并且其亦可转换/保持态射（m
    
    </summary>
    
      <category term="Functional Programming" scheme="http://blog.jasonding.top/categories/Functional-Programming/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
      <category term="Functional Programming" scheme="http://blog.jasonding.top/tags/Functional-Programming/"/>
    
  </entry>
  
  <entry>
    <title>【函数式】Monads模式初探——Monoids</title>
    <link href="http://blog.jasonding.top/2016/02/22/Functional%20Programming/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91Monads%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94Monoids/"/>
    <id>http://blog.jasonding.top/2016/02/22/Functional Programming/【函数式】Monads模式初探——Monoids/</id>
    <published>2016-02-22T08:22:05.000Z</published>
    <updated>2016-03-16T06:24:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Monads是什么"><a href="#Monads是什么" class="headerlink" title="Monads是什么"></a>Monads是什么</h2><p>知乎里有关于<a href="https://www.zhihu.com/question/19635359" target="_blank" rel="external">什么是Monad</a>的问题讨论，而在维基百科中也有关于<a href="https://en.wikipedia.org/wiki/Monad_(functional_programming" target="_blank" rel="external">Monad的释义</a>)。作为初次接触到Monads概念，难免会有些晕头转向，也难免会有些畏惧（因为Monads和数学中的范畴论有密切关系），但是Monads又是如此的重要，因为它在函数式编程中实在是应用太广泛了，并且在Scala的标准库中又常常遇到，使得我们不得不好好研究一番。</p>
<h2 id="Monoids"><a href="#Monoids" class="headerlink" title="Monoids"></a>Monoids</h2><p>Monoids是一种元素的集合，它需要满足结合律和幺元（Identity，也称为单位元，这种元和其他元素结合时，不会改变那么元素）这些约束条件。<br>比如：</p>
<blockquote>
<ul>
<li>整数类型Int，其中0是Identity，其中的任何整数满足结合律</li>
<li>列表类型List，任何两个列表可以通过<code>:::</code>连接起来，其中Nil或空列表[]是Identity</li>
<li>字符串类型String，两个字符串可以拼接，其中空字符串或””是Identity</li>
</ul>
</blockquote>
<p>Monoids在平常的编程之中无处不在，当用到一个列表，连接字符串，通过一个循环得到一个累加结果，都在使用到Monoids。</p>
<h3 id="条件和定律"><a href="#条件和定律" class="headerlink" title="条件和定律"></a>条件和定律</h3><blockquote>
<ol>
<li>一个抽象类型A</li>
<li>一个二元结合性函数（binary associative function），对传入的两个A类参数进行操作后产生一个A类型结果。op操作必须是结合性的，即op(x, y) == op(y, x)；op(a,op(b,c)) = op(op(a,b),c)：这个定律是函数组合（function composition）不可缺的条件</li>
<li>一个恒等值（identity）。二元函数参数中如果有一个是恒等值时操作结果为另一个参数，即满足op(identity, x) == x</li>
</ol>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>Monoid可以用下面的代码描述：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">trait Monoid[T] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span><span class="params">(m1: T, m2: T)</span>:</span> T</div><div class="line">  val identity: T</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个特质可以被混入类型（classes）、对象（objects）或者其他特质中。请看下面的举例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StringMonoid</span> <span class="keyword">extends</span> <span class="title">Monoid</span>[<span class="type">String</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(s1: <span class="type">String</span>, s2: <span class="type">String</span>) = s1 + s2</div><div class="line">  <span class="keyword">val</span> identity = <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> stringMonoid = <span class="type">StringMonoid</span>()</div><div class="line">println(stringMonoid.op(stringMonoid.identity, <span class="string">"John"</span>))</div><div class="line">println(stringMonoid.op(<span class="string">"John"</span>, <span class="string">"Hunt"</span>))</div><div class="line"><span class="comment">// Output is</span></div><div class="line"><span class="comment">// John</span></div><div class="line"><span class="comment">// JohnHunt</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">IntMonoid</span> <span class="keyword">extends</span> <span class="title">Monoid</span>[<span class="type">Int</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = x + y</div><div class="line">  <span class="keyword">val</span> identity = <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">println(<span class="type">IntMonoid</span>.op(<span class="type">IntMonoid</span>.identity, <span class="number">1</span>))</div><div class="line">println(<span class="type">IntMonoid</span>.op(<span class="number">1</span>, <span class="number">2</span>))</div><div class="line">println(<span class="type">IntMonoid</span>.op(<span class="number">2</span>, <span class="number">1</span>))</div><div class="line"><span class="comment">// Output is</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<h2 id="Monoid和折叠"><a href="#Monoid和折叠" class="headerlink" title="Monoid和折叠"></a>Monoid和折叠</h2><p>如果有一个Monoid结构和一组数据。可以通过对每个元素进行Monoid的op操作来将集合缩减为一个值，比如将一个整数列表通过元素累加的方式得到所有整数的和。<br>Monoid和List有着密切的联系。在List的foldLeft操作中，用一个初始元素从列表的左边元素开始操作，一直到对所有元素都操作完。如<code>List(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;).foldLeft(&quot;&quot;)(_ + _)</code>这个对字符串列表实现累加功能，foldLeft传入的两个参数分别是空字符串和二元操作运算，这正好符合Monoid的定义，可以轻松利用StringMonoid代替，<code>List(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;).foldLeft(StringMonoid.identity)(StringMonoid.op)</code>。</p>
<h2 id="结合性与并行化"><a href="#结合性与并行化" class="headerlink" title="结合性与并行化"></a>结合性与并行化</h2><p>Monoid的结合性意味着我们在对类似List的数据结构进行折叠的时候有很大的灵活性。我们已经知道可以使用foldLeft和foldRight对一个列表进行顺序的规则（reduce）操作。但是我们同样可以将数据分成多份，并行的进行折叠，然后利用monoid将各个部分合并起来。<br>左折叠操作是<code>op(op(op(a, b), c), d)</code><br>右折叠操作是<code>op(a, op(b, op(c, d)))</code><br>并行算法为<code>op(op(a, b), op(c, d))</code>，其中op(a, b)和op(c, d)是同时运算的。<br>如果我们对一个超大文件进行文字数统计或者寻找最大值什么的，我们可以把这个大文件分成若干小文件然后同时计算后再合计将节省很多计算时间。</p>
<h2 id="Monoid模式的优缺点"><a href="#Monoid模式的优缺点" class="headerlink" title="Monoid模式的优缺点"></a>Monoid模式的优缺点</h2><p>优点：</p>
<ul>
<li>Monoid模式提供了一种在特定场景下将元素合并的标准方法</li>
<li>结合性的保证可以用来定义函数之间组合</li>
</ul>
<p>缺点：</p>
<ul>
<li>并不是所有集合都可以很容易的应用Monoid模式。比如String Monoid，不同顺序的字符串进行连接可能会得到不同的结果。</li>
</ul>
<h2 id="从范畴论到计算机编程"><a href="#从范畴论到计算机编程" class="headerlink" title="从范畴论到计算机编程"></a>从范畴论到计算机编程</h2><p>从Monoid到Monad，这些概念都是从范畴论中衍生出来的。<br>理解范畴论的一个好方法是把它理解为应用到函数式编程领域的设计模式。范畴论定义了一些非常底层的概念抽象，这些概念可以直接用Scala这样的支持函数式编程的语言表达。在设计软件的时候，如果一个特定实体符合其中一个概念，那么立刻就有一整组操作可用，而且包含推理其用法的方法。</p>
<p>范畴是由元素对象和态射箭头组成的，这个箭头开始端是一个元素对象，目的地也是一个元素对象。这里态射箭头有两种，不同元素对象比如a和b之间的态射箭头称为组合箭头，而指向自己的箭头称为元箭头，或者单元，幺元。</p>
<p>范畴的元素对象和箭头态射的规则如下：</p>
<blockquote>
<ol>
<li>对于箭头f:a -&gt; b和箭头g:b -&gt; c，如果有一个箭头h: a -&gt; c，那么就称为它们的组合，写法是：h=g·f</li>
<li>对于每个元素对象，都有一个单元箭头：id:a -&gt; a。对于任何f: a -&gt; b，满足f·id = f；对于任何g: c -&gt; a，满足id·g = g</li>
<li>组合符合结合律：f·(g·h) = (f·g)·h<br>态射箭头有两种，一种是标号1的组合箭头，还有一种是标号2的单元箭头。<br><img src="http://7nj1qk.com1.z0.glb.clouddn.com/%40%2Fscala%2Ffunctional%2Fmorphism.png" alt=""></li>
</ol>
</blockquote>
<p><strong>我们将一个范畴有元素对象和态射箭头，态射箭头有组合和幺元两种，且满足结合律，这种范畴称为Monoid。</strong></p>
<p>对于某非空集合S，若存在S上的二元运算”*“使得对于任意的a,b∈S,有a<em>b∈S（运算封闭），则称{S,\</em>}为广群。　广群只是定义一个集合，集合中有元素和操作，操作结果也属于这个集合，这样泛泛的集合称为广群。　如果广群再加上结合律约束，就会得到半群，因此半群是广群的子集，要求更苛刻些，而半群如果再加上幺元（identity element）就是幺半群，也就是结合律+幺元=幺半群，所以，Monid对应的中文是幺半群。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://download.csdn.net/detail/u013055255/6989227" target="_blank" rel="external">Functional Programming in Scala</a><br><a href="http://download.csdn.net/detail/jasonding1354/8852933" target="_blank" rel="external">Scala Design Patterns: Patterns for Practical Reuse and Design</a><br><a href="http://www.jdon.com/idea/monoid.html" target="_blank" rel="external">什么是Monoid？</a><br><a href="http://hongjiang.info/fold-and-mon" target="_blank" rel="external">我所理解的monad(2)：fold与monoid</a></p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding1354.github.io/" target="_blank" rel="external">Github博客主页(http://jasonding1354.github.io/)</a><br><a href="http://jasonding1354.gitcafe.io/" target="_blank" rel="external">GitCafe博客主页(http://jasonding1354.gitcafe.io/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Monads是什么&quot;&gt;&lt;a href=&quot;#Monads是什么&quot; class=&quot;headerlink&quot; title=&quot;Monads是什么&quot;&gt;&lt;/a&gt;Monads是什么&lt;/h2&gt;&lt;p&gt;知乎里有关于&lt;a href=&quot;https://www.zhihu.com/quest
    
    </summary>
    
      <category term="Functional Programming" scheme="http://blog.jasonding.top/categories/Functional-Programming/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
      <category term="Functional Programming" scheme="http://blog.jasonding.top/tags/Functional-Programming/"/>
    
  </entry>
  
  <entry>
    <title>【Scala类型系统】隐式转换与隐式参数</title>
    <link href="http://blog.jasonding.top/2016/02/21/Scala/%E3%80%90Scala%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E3%80%91%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0/"/>
    <id>http://blog.jasonding.top/2016/02/21/Scala/【Scala类型系统】隐式转换与隐式参数/</id>
    <published>2016-02-21T08:56:16.000Z</published>
    <updated>2016-03-16T06:24:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>隐式转换是使用implicit修饰的带有单个参数的普通函数。这种函数将自动应用，将值从一种类型转换为另一种类型。<br>举例说明：</p>
<blockquote>
<p>我们想将整数n转换为分数n/1，<br>定义<code>implicit def int2Fraction(n: Int) = Fraction(n, 1)</code><br>在进行如下表达式求值的时候：<br><code>val result = 3 * Fraction(4, 5)</code><br>编译器将调用int2Fraction(3)，将整数转换成一个Fraction对象，然后按照Fraction类的*方法定义来进行计算。</p>
</blockquote>
<p>隐式转换可以为现有的类库添加功能：</p>
<blockquote>
<p>我们想为java.io.File类添加一个read方法来读取文件<br>在Scala中，可以定义一个类型来提供read或你想要的功能：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> RichFile(val <span class="keyword">from</span>: <span class="keyword">File</span>) &#123;</div><div class="line">  <span class="keyword">def</span> <span class="keyword">read</span> = <span class="keyword">Source</span>.fromFile(<span class="keyword">from</span>.getPath).mkString</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>然后再提供一个隐式转换来将原来的File类型转换到新定义的类型：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">implicit</span> def file2RichFile(from: <span class="keyword">File</span>) = new RichFile(from)</div></pre></td></tr></table></figure></p>
<p>这样就可以在File对象上调用read方法了，它被隐式转换为一个RichFile对象。</p>
<h2 id="隐式转换的规则"><a href="#隐式转换的规则" class="headerlink" title="隐式转换的规则"></a>隐式转换的规则</h2><h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><p>隐式转换函数的可用位置：</p>
<blockquote>
<ol>
<li>位于源或目标类型的伴生对象中的隐式函数</li>
<li>位于当前作用域可以以单个标识符指代的隐式函数</li>
</ol>
</blockquote>
<p>假如隐式函数放在了Conversions对象中，而这个对象位于com.xxx.yyy包，那么引入语句应该是：<code>import com.xxx.yyy.Conversions._</code>。</p>
<h3 id="无歧义规则"><a href="#无歧义规则" class="headerlink" title="无歧义规则"></a>无歧义规则</h3><p>隐式转换的应用场景：</p>
<blockquote>
<ul>
<li>当表达式的类型与预期的类型不同时：<br>比如<code>sqrt(Fraction(1, 4))</code>中，sqrt期望一个Double的参数，编译器会调用类似fraction2Double的隐式函数来将Fraction对象转换为Double对象。</li>
<li>当对象访问一个不存在的成员时：<br>比如<code>new File(&quot;README&quot;).read</code>中，File没有read方法，编译器会调用file2RichFile，然后调用RichFile中定义的read方法。</li>
<li>当对象调用某个方法，而该方法的参数声明与传入参数不匹配时：<br>比如<code>3 * Fraction(4, 5)</code>中，Int类的*方法不接收Fraction作为参数，编译器会调用int2Fraction进行隐式转换。</li>
</ul>
</blockquote>
<p>编译器不会使用隐式转换的情况：</p>
<blockquote>
<ul>
<li>如果代码能够不适用隐式转换的前提下通过编译，则不会使用隐式转换。</li>
<li>编译器不会尝试同时执行多个转换，所以隐式转换是单一调用的。</li>
<li>存在二义性的转换是错误的，编译器将会报错。</li>
</ul>
</blockquote>
<h2 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h2><p>函数或方法可以带有一个标记为implicit的参数列表。该情况下，编译器会查找缺省值，提供给该函数或方法。<br>比如:<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="keyword">class</span> Delimiters(left: String, right: String)</div><div class="line"></div><div class="line">def quote(what: String)(<span class="keyword">implicit</span> delims: Delimiters) =</div><div class="line">  delims.left + what + delims.right</div><div class="line"></div><div class="line"><span class="keyword">implicit</span> val quoteDelimiters = Delimiters(<span class="string">"&lt;&lt;"</span>, <span class="string">"&gt;&gt;"</span>)</div></pre></td></tr></table></figure></p>
<p>当我们调用<code>quote(&quot;Scala Programming&quot;)</code>时，编译器会查找一个类型为Delimiters的隐式值，输出<code>&lt;&lt;Scala Programming&gt;&gt;</code>。</p>
<p>编译器的查找位置：</p>
<blockquote>
<ul>
<li>当前作用域所有可用单个标识符指代的满足类型要求的val和def</li>
<li>与所要求类型相关联的类型的繁盛对象。相关联的类型包括所要求类型本身，以及它的类型参数。</li>
</ul>
</blockquote>
<h3 id="利用隐式参数进行隐式转换"><a href="#利用隐式参数进行隐式转换" class="headerlink" title="利用隐式参数进行隐式转换"></a>利用隐式参数进行隐式转换</h3><p>我们提供一个泛型函数来得到相对小的值：<br><code>def smaller[T](a: T, b: T) = if (a &lt; b) a else b</code><br>这里由于我们并不知道a和b的类型是否有&lt;操作符，所以编译器不会通过。<br>解决办法是添加一个隐式参数order来指代一个转换函数：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def smaller(a: T, b: T)(<span class="keyword">implicit</span> order: T =&gt; Ordered[T])</div><div class="line">  = <span class="keyword">if</span>(order(a) &lt; b) a <span class="keyword">else</span> b</div></pre></td></tr></table></figure></p>
<p>由于Ordered[T]特质中有一个接受T作为参数的&lt;方法，所以编译器将在编译时知道T，并且从而判决是否T =&gt; Ordered[T]类型的隐式定义存在于作用域中。<br>这样，才可以调用<code>smaller(40, 2)</code>或者<code>smaller(&quot;AA&quot;, &quot;BB&quot;)</code>。<br>注意，order是一个带有单个参数的函数，被打上了implicit标签，所以它不仅是一个隐式参数，也是一个隐式转换。那么，我们可以在函数体重省略order的显示调用。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def smaller[T](a: T, b: T)(<span class="keyword">implicit</span> order: T =&gt; Ordered[T])</div><div class="line">  = <span class="keyword">if</span> (a &lt; b) a <span class="keyword">else</span> b</div></pre></td></tr></table></figure></p>
<p>因为a没有带&lt;的方法，那么会调用order(a)进行转换。</p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;隐式转换&quot;&gt;&lt;a href=&quot;#隐式转换&quot; class=&quot;headerlink&quot; title=&quot;隐式转换&quot;&gt;&lt;/a&gt;隐式转换&lt;/h2&gt;&lt;p&gt;隐式转换是使用implicit修饰的带有单个参数的普通函数。这种函数将自动应用，将值从一种类型转换为另一种类型。&lt;br&gt;举例
    
    </summary>
    
      <category term="Scala" scheme="http://blog.jasonding.top/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>【Scala类型系统】函数式Queue的简易实现</title>
    <link href="http://blog.jasonding.top/2016/02/20/Scala/%E3%80%90Scala%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E3%80%91%E5%87%BD%E6%95%B0%E5%BC%8FQueue%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.jasonding.top/2016/02/20/Scala/【Scala类型系统】函数式Queue的简易实现/</id>
    <published>2016-02-20T09:04:50.000Z</published>
    <updated>2016-03-16T06:24:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现一个函数式Queue泛型类"><a href="#实现一个函数式Queue泛型类" class="headerlink" title="实现一个函数式Queue泛型类"></a>实现一个函数式Queue泛型类</h2><p>函数式队列是一种具有以下三种操作方式的数据结构：</p>
<blockquote>
<p>head  返回队列的第一个元素<br>tail    返回除第一个元素之外的队列<br>append  返回尾部添加了指定元素的新队列</p>
</blockquote>
<p>如果Queue是一个不变队列，也就是函数式队列。在添加元素的时候不会改变其内容，而是返回包含了这个元素的新队列。<br>如果Queue是可变类型的，那么append操作将改变队列的内容。<br>纯函数式队列和List具有相似性，都支持head和tail操作。可以通过List来实现函数式队列。</p>
<p>关于时间开销问题，append操作应该在常量时间内完成。<br>为了做到这一点，我们使用两个List，分别称为leading和trailing，来表达队列。leading包含前段元素，而trailing包含了反向排列的后段元素。队列在任何时刻的所有内容都可以表示为<code>leading ::: trailing.reverse</code>。</p>
<blockquote>
<ul>
<li>想要添加新元素，只要使用::操作符将其添加到trailing，使得append是常量时间。</li>
<li>当原始的空队列通过后继的append操作构建起来时，trailing将不断增加，而leading始终是空白的。于是，在对空的leading第一次执行head或者tail操作之前，trailing应该被反转并复制给leading，这个操作称为mirror。</li>
<li>mirror操作花费的时间大概与队列的元素数量成正比，但仅在leading为空时。如果leading非空，它将直接返回。</li>
<li>因为head和tail调用了mirror，所以他们的复杂度与队列长度呈线性关系。实际上，假设leading为空时，mirror才翻转并复制，那么n个元素需要进行n次tail之后才进行复制。这n次tail操作平均分担了mirror操作的时间复杂度，也相当于常量时间了。</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>[<span class="type">T</span>] (<span class="params">private val leading: <span class="type">List</span>[<span class="type">T</span>],</span></span></div><div class="line">                private val trailing: <span class="type">List</span>[<span class="type">T</span>])</div><div class="line">&#123;</div><div class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">mirror</span> </span>=</div><div class="line">    <span class="keyword">if</span> (leading.isEmpty)</div><div class="line">      <span class="keyword">new</span> <span class="type">Queue</span>(trailing.reverse, <span class="type">Nil</span>)</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="keyword">this</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span> </span>= mirror.leading.head</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span> </span>= &#123;</div><div class="line">    <span class="keyword">val</span> q = mirror</div><div class="line">    <span class="keyword">new</span> <span class="type">Queue</span>(q.leading.tail, q.trailing)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">append</span></span>(element: <span class="type">T</span>) =</div><div class="line">    <span class="keyword">new</span> <span class="type">Queue</span>(leading, element :: trailing)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="信息隐藏"><a href="#信息隐藏" class="headerlink" title="信息隐藏"></a>信息隐藏</h2><h3 id="私有构造器和工厂方法"><a href="#私有构造器和工厂方法" class="headerlink" title="私有构造器和工厂方法"></a>私有构造器和工厂方法</h3><p>上面实现的Queue以暴露本不该暴露的实现细节为代价，全局可访问Queue构造器，带有两个列表参数，不能作为直观表达队列的形式。<br>私有构造器和私有成员是隐藏类的初始化代码和表达代码的一种方式。<br>可以通过把private修饰符添加在类参数列表的前面把主构造器隐藏起来。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>[<span class="title">T</span>] <span class="keyword">private</span> </span>(<span class="keyword">private</span> <span class="keyword">val</span> leading: List[T],</div><div class="line">                        <span class="keyword">private</span> <span class="keyword">val</span> trailing: List[T])</div></pre></td></tr></table></figure></p>
<p>构造器是私有的，它只能被类本身及伴生对象访问。我们可以添加可以用初始元素序列创建队列的工厂方法。定义与类同名的Queue对象及apply方法：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object Queue &#123;</div><div class="line">  def apply[<span class="string">T</span>](<span class="link">xs: T*</span>) = new Queue[<span class="string">T</span>](<span class="link">xs.toList, Nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="私有类"><a href="#私有类" class="headerlink" title="私有类"></a>私有类</h3><p>使用私有类的方法可以更彻底的把类本身隐藏掉，仅提供能够暴露类公共接口的特质。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Queue</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">T</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">Queue</span>[<span class="type">T</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">append</span></span>(x: <span class="type">T</span>): <span class="type">Queue</span>[<span class="type">T</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](xs: <span class="type">T</span>*): <span class="type">Queue</span>[<span class="type">T</span>] =</div><div class="line">    <span class="keyword">new</span> <span class="type">QueueImpl</span>[<span class="type">T</span>](xs.toList, <span class="type">Nil</span>)</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueImpl</span>[<span class="type">T</span>](<span class="params"></span></span></div><div class="line">                             private val leading: <span class="type">List</span>[<span class="type">T</span>],</div><div class="line">                             private val trailing: <span class="type">List</span>[<span class="type">T</span>]</div><div class="line">                               ) <span class="keyword">extends</span> <span class="title">Queue</span>[<span class="type">T</span>]</div><div class="line">  &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirror</span> </span>=</div><div class="line">      <span class="keyword">if</span> (leading.isEmpty)</div><div class="line">        <span class="keyword">new</span> <span class="type">QueueImpl</span>(trailing.reverse, <span class="type">Nil</span>)</div><div class="line">      <span class="keyword">else</span></div><div class="line">        <span class="keyword">this</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">T</span> = mirror.leading.head</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">QueueImpl</span>[<span class="type">T</span>] = &#123;</div><div class="line">      <span class="keyword">val</span> q = mirror</div><div class="line">      <span class="keyword">new</span> <span class="type">QueueImpl</span>(q.leading.tail, q.trailing)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span></span>(x: <span class="type">T</span>) =</div><div class="line">      <span class="keyword">new</span> <span class="type">QueueImpl</span>(leading, x:: trailing)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码中定义了特质Queue，声明了方法head、tail和append。<br>这三个方法都实现在子类QueueImpl中，而它本身是对象Queue的内部类。这个方案暴露给客户的信息与前面相同，但使用了不同的技术。代之以逐个隐藏构造器与方法，这个版本隐藏全部实现类。</p>
<h2 id="实现协变的泛型类"><a href="#实现协变的泛型类" class="headerlink" title="实现协变的泛型类"></a>实现协变的泛型类</h2><p>使用Queue[+T]方式对Queue实现协变，然而在append的实现中，T参数出现在了逆变的位置。<br>可以通过把append变为多态以使其泛型化（即提供给append方法类型参数）并使用它的类型参数的下界。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>[+<span class="title">T</span>] <span class="keyword">private</span> </span>(</div><div class="line">    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> leading: List[T],</div><div class="line">    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> trailing: List[T]</div><div class="line">) &#123;</div><div class="line">  def append[U &gt;: T](x: U) =</div><div class="line">    new Queue[U](leading, x::trailing)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过<code>U &gt;: T</code>定义了T为U的下界。结果U必须是T的超类型。<br>假设存在类Fruit和两个子类，Apple和Orange。通过Queue类的定义，可以吧Orange对象加入到Queue[Apple]，结果返回Queue[Fruit]类型。</p>
<h2 id="对象私有数据"><a href="#对象私有数据" class="headerlink" title="对象私有数据"></a>对象私有数据</h2><p>到目前为止，Queue类仍有一些问题。如果head被一遍遍的调用很多次，而leading列表为空，那么mirror操作可能会重复的把trailing复制到leading列表。<br>可以将leading和trailing指定为可以重新复制的变量，而mirror从trailing反向复制到leading的操作是在当前队列上的副作用，而不再返回新的队列。<br>通过将leading和trailing用private[this]修饰，声明为对象私有变量，使得这种副作用纯粹是Queue操作的内部实现，从而使它对于Queue的客户不可见。<br>代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Queue[+T] <span class="keyword">private</span> (</div><div class="line">                        <span class="keyword">private</span>[<span class="keyword">this</span>] var leading: List[T],</div><div class="line">                        <span class="keyword">private</span>[<span class="keyword">this</span>] var trailing: List[T]</div><div class="line">                          ) &#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">def</span> mirror() =</div><div class="line">    <span class="keyword">if</span>(leading.isEmpty) &#123;</div><div class="line">      <span class="keyword">while</span>(!trailing.isEmpty) &#123;</div><div class="line">        leading = trailing.head :: leading</div><div class="line">        trailing = trailing.tail</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="keyword">def</span> head: T = &#123;</div><div class="line">    mirror()</div><div class="line">    leading.head</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">def</span> tail: Queue[T] = &#123;</div><div class="line">    mirror()</div><div class="line">    <span class="keyword">new</span> Queue(leading.tail, trailing)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">def</span> <span class="keyword">append</span>[U &gt;: T](x: U) =</div><div class="line">    <span class="keyword">new</span> Queue[U](leading, x::trailing)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明：<br>被定义在同一个对象内访问对象私有变量不会引起与变化型有关的问题。Scala的变化型检查规则包含了关于对象私有定义的特例。当检查到带有+/-号的类型参数只出现在具有相同变化型分类的位置上时，这种定义将被忽略。</p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding.top" target="_blank" rel="external">jasonding.top</a><br><a href="http://blog.jasonding.top/">Github博客主页(http://blog.jasonding.top/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实现一个函数式Queue泛型类&quot;&gt;&lt;a href=&quot;#实现一个函数式Queue泛型类&quot; class=&quot;headerlink&quot; title=&quot;实现一个函数式Queue泛型类&quot;&gt;&lt;/a&gt;实现一个函数式Queue泛型类&lt;/h2&gt;&lt;p&gt;函数式队列是一种具有以下三种操作方式
    
    </summary>
    
      <category term="Scala" scheme="http://blog.jasonding.top/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>【Scala类型系统】类型参数化和变化型注解</title>
    <link href="http://blog.jasonding.top/2016/02/20/Scala/%E3%80%90Scala%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E3%80%91%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%8C%96%E5%92%8C%E5%8F%98%E5%8C%96%E5%9E%8B%E6%B3%A8%E8%A7%A3/"/>
    <id>http://blog.jasonding.top/2016/02/20/Scala/【Scala类型系统】类型参数化和变化型注解/</id>
    <published>2016-02-20T02:47:44.000Z</published>
    <updated>2016-03-16T06:24:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>类型参数化（Parameterized Types）可以用来编写泛型类和特质，比如定义Set[T]，这使得我们可以创建诸如Set[String]的类型。而变化型注解（Variance Annotation）定义了参数化类型的继承关系，比如Set[String]是Set[AnyRef]的子类型。<br>这些语法可以让我们实现信息隐藏技术，同时它们也是编写库程序的基础。</p>
<h2 id="类型参数化"><a href="#类型参数化" class="headerlink" title="类型参数化"></a>类型参数化</h2><p>这里以水果盒的代码作为例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span></span>: <span class="type">String</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= <span class="string">"orange"</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= <span class="string">"apple"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fruit</span></span>: <span class="type">Fruit</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(aFruit: <span class="type">Fruit</span>) =</div><div class="line">    fruit.name.equals(aFruit.name)</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrangeBox</span>(<span class="params">orange: <span class="type">Orange</span></span>) <span class="keyword">extends</span> <span class="title">Box</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fruit</span></span>: <span class="type">Orange</span> = orange</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleBox</span>(<span class="params">apple: <span class="type">Apple</span></span>) <span class="keyword">extends</span> <span class="title">Box</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fruit</span></span>: <span class="type">Apple</span> = apple</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子，定义了Box的两个子类，OrangeBox和AppleBox，这考虑的类型安全，因为fruit方法的返回值受到了Orange和Apple类型的特别限制。这也同样带来了维护代码量和类型安全的矛盾。<br>基于这个问题，Scala允许使用参数化类型，即你可以使用类型参数来代替实际的类型。类型参数可以认为是一个限制类型的别名。</p>
<p>根据类型继承关系，Scala编译器允许AppleBox或者OrangeBox的实例赋值给Box类型变量，在Box子类中fruit方法的实现返回了Apple或者Orange类型，这同样可以赋值给Fruit类型的变量。</p>
<p><strong>变化型注解</strong>：</p>
<blockquote>
<ul>
<li>假设声明了<code>class Orange extends Fruit</code>，而后<code>class Box[A]</code>中的A可以有前缀+或-。</li>
<li>A，没有任何注解，是不变型。该状态下，<code>Box[Orange]</code>和<code>Box[Fruit]</code>没有任何继承关系</li>
<li>+A，是协变类型。此时，<code>Box[Orange]</code>是<code>Box[Fruit]</code>的子类型，并且变量声明<code>val f: Box[Fruit] = new Box[Orange]()</code>是允许的。</li>
<li>-A，是逆变类型。此时，<code>Box[Fruit]</code>是<code>Box[Orange]</code>的子类型，并且变量声明<code>val f: Box[Orange] = new Box[Fruit]()</code>是允许的。</li>
</ul>
</blockquote>
<p><img src="http://7nj1qk.com1.z0.glb.clouddn.com/%40%2Fscala%2Ftype_system%2Fvariance_annotations.jpg" alt=""><br>从总体来看，变化类型参数可以被认为是扩展泛型编程的类型检查范围的工具。它提供了额外的类型安全，即保证类型安全的前提下，为开发者提供了利用类型层级的可能性。</p>
<h2 id="子类型多态"><a href="#子类型多态" class="headerlink" title="子类型多态"></a>子类型多态</h2><p>协变和逆变注解使得通过类型参数的继承关系来推断泛化类型的继承关系，利用该注解可以限制类型参数在泛型类中一些可能的使用，Scala编译器针对不恰当的使用进行检查和报错。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>[+<span class="type">F</span> &lt;: <span class="type">Fruit</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fruit</span></span>: <span class="type">F</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(aFruit: <span class="type">Fruit</span>) = fruit.name.equals(aFruit.name)</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrangeBox</span>(<span class="params">orange: <span class="type">Orange</span></span>) <span class="keyword">extends</span> <span class="title">Box</span>[<span class="type">Orange</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fruit</span> </span>= orange</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleBox</span>(<span class="params">apple: <span class="type">Apple</span></span>) <span class="keyword">extends</span> <span class="title">Box</span>[<span class="type">Apple</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fruit</span> </span>= apple</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fruitBox: <span class="type">Box</span>[<span class="type">Fruit</span>] = <span class="keyword">new</span> <span class="type">AppleBox</span>(<span class="keyword">new</span> <span class="type">Apple</span>)</div><div class="line"><span class="keyword">var</span> fruit: <span class="type">Fruit</span> = fruitBox.fruit</div></pre></td></tr></table></figure></p>
<p>上面的例子中，Box[+F]类型参数是协变的，那么将Box[Apple]赋值给Box[Fruit]类型变量fruitBox是合法的。类型变量F用在函数返回类型中是合理的（比如Box.fruit），在fruitBox.fruit方法的调用中，保证返回给Fruit类的实例是一个更加具体的类型，由于类型参数是协变的，需要返回一个比Fruit类型更加具象的类型。</p>
<h2 id="协变和逆变点"><a href="#协变和逆变点" class="headerlink" title="协变和逆变点"></a>协变和逆变点</h2><p><strong>函数在参数上是逆变的，在返回值上则是协变的</strong>。通常而言，对于某个对象消费的值适用逆变，而对于它产出的值适用协变。<br>如果一个对象同时消费和产出某值，则类型应该保持不变。这通常适用于可变数据结构，比如标准库中的Array、ArrayBuffer、ListBuffer等。</p>
<h2 id="Scala编译器检查变化型注解的机制"><a href="#Scala编译器检查变化型注解的机制" class="headerlink" title="Scala编译器检查变化型注解的机制"></a>Scala编译器检查变化型注解的机制</h2><p>为了核实变化型注解的正确性，Scala编译器会把类或特质中可能用到类型参数的地方分类为正，负或中立。注解了+号的类型参数只能被用在正的位置上，而注解了-号的类型参数只能用在负的位置上。没有变化型注解的类型参数可以用于任何位置。<br>Scala编译器在检查泛型类时，会跟踪所有使用类型参数的位置，然后根据代码中变化型的位置来决定正确与否。如果类型参数出现在了禁止的位置，编译器将会报错。详细的检查规则可以参见<a href="http://www.scala-lang.org/files/archive/spec/2.11/04-basic-declarations-and-definitions.html#variance-annotations" target="_blank" rel="external">这里</a>。</p>
<p>为了对用到类型参数的地方进行分类，编译器首先从类型参数的声明开始，然后进入更深的内嵌层。<br>处于声明类的<strong>最顶层被划为正</strong>，默认情况下，更深的内嵌层的地方的分类会与它外层一致，但仍有几种特殊情况可以使得类型参数的类型发生翻转：</p>
<blockquote>
<ol>
<li>方法的值参数位置的参数类型</li>
<li>方法的类型参数子句位置的参数类型</li>
<li>类型参数的下界的下界参数类型</li>
<li>参数化类型的类型参数，当类型参数是逆变时<br>类型的类型参数位置，比如C[Arg]的Arg，也有可能被翻转，如果C的类型参数标注了+，那么类别不变；如果C的类型参数标注了-，那么当前类别被翻转。</li>
</ol>
<p>举例解释：</p>
<ul>
<li><code>def method(parameter: T)</code>中，参数T在逆变的位置，遵循第一条规则</li>
<li><code>def method[U &lt;: T]</code>中，参数T在逆变的位置，遵循第二条规则</li>
<li><code>def method[U &gt;: T]</code>中，参数T在协变的位置，循序第二条和第三条规则</li>
<li><code>class Box[-A]</code>中，Box被声明为逆变，此情况下，<code>def method(parameter: Box[T])</code>中的T应该是协变的位置，遵循第一条和第四条规则</li>
</ul>
</blockquote>
<h2 id="下界"><a href="#下界" class="headerlink" title="下界"></a>下界</h2><p>在一个方法的类型参数子句中的下界参数，为何从逆变位置翻转成协变？<br>Box[+T]中的协变类型参数T，根据子类型多态性，只能变得更加具象，也就是说，受到T的限制，其实类型将沿着类型层级往下走。如果将T作为下界，使用<code>U &gt;: T</code>中的U来作为类型约束，则是可行的。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Box[<span class="string">+T</span>](<span class="link">fruit: T</span>) &#123;</div><div class="line">  def method[<span class="string">U &gt;: T</span>](<span class="link">p: U</span>) = &#123; new Box[<span class="string">U</span>](<span class="link">p</span>) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var apple: Apple = new Apple</div><div class="line">var box: Box[<span class="string">Fruit</span>] = new Box[<span class="string">Orange</span>](<span class="link">new Orange</span>)</div><div class="line">box = box.method(apple)</div></pre></td></tr></table></figure></p>
<p>这个例子中，即使box在实例化的时候复制为一个子类型Box[Orange]，Box.method的调用仍然是合法的。<br>通过语法<code>U &gt;: T</code>，定义了T为U的下界。结果，U必须是T的超类型，method的参数也变为类型U而不是类型T，而方法返回值也变成了Box[U]，取代了Box[T]。<br>通过把Apple对象加入到Box[Orange]中，返回结果为Box[Fruit]类型。</p>
<h2 id="合法的变化型位置"><a href="#合法的变化型位置" class="headerlink" title="合法的变化型位置"></a>合法的变化型位置</h2><p>下面的几种变化型参数均为合法的语法格式：</p>
<blockquote>
<ul>
<li><code>abstract class Box[+A]{ def foo(): A }</code></li>
<li><code>abstract class Box[-A]{ def foo(a: A) }</code></li>
<li><code>abstract class Box[+A]{ def foo[B &gt;: A](b: B) }</code></li>
<li><code>abstract class Box[-A]{ def foo[B &lt;: A](): B}</code></li>
</ul>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.codecentric.de/en/2015/04/the-scala-type-system-parameterized-types-and-variances-part-2/" target="_blank" rel="external">The Scala Type System: Parameterized Types and Variances</a></p>
<p><strong>转载请注明作者Jason Ding及其出处</strong><br><a href="http://jasonding1354.github.io/" target="_blank" rel="external">Github博客主页(http://jasonding1354.github.io/)</a><br><a href="http://jasonding1354.gitcafe.io/" target="_blank" rel="external">GitCafe博客主页(http://jasonding1354.gitcafe.io/)</a><br><a href="http://blog.csdn.net/jasonding1354" target="_blank" rel="external">CSDN博客(http://blog.csdn.net/jasonding1354)</a><br><a href="http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles" target="_blank" rel="external">简书主页(http://www.jianshu.com/users/2bd9b48f6ea8/latest_articles)</a><br><strong>Google搜索jasonding1354进入我的博客主页</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;类型参数化（Parameterized Types）可以用来编写泛型类和特质，比如定义Set[T]，这使得我们可以创建诸如Set[Strin
    
    </summary>
    
      <category term="Scala" scheme="http://blog.jasonding.top/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://blog.jasonding.top/tags/Scala/"/>
    
  </entry>
  
</feed>
